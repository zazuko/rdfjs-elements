import{S as Qt}from"./index-BOvYCoiN.js";import{h as Xt,g as Kt,b as Wt}from"./index-CP8saq_h.js";import{r as Ct}from"./canonicalize-CMDVY_Xn.js";var ye={},me,st;function Ze(){return st||(st=1,me=class Bt{constructor(r,g=new Map,m=0){this.prefix=r,this._existing=g,this.counter=m}clone(){const{prefix:r,_existing:g,counter:m}=this;return new Bt(r,new Map(g),m)}getId(r){const g=r&&this._existing.get(r);if(g)return g;const m=this.prefix+this.counter;return this.counter++,r&&this._existing.set(r,m),m}hasId(r){return this._existing.has(r)}getOldIds(){return[...this._existing.keys()]}}),me}var ve={},it;function Yt(){return it||(it=1,function(x,r){if(x.setImmediate)return;var g=1,m={},L=!1,i=x.document,t;function n(T){typeof T!="function"&&(T=new Function(""+T));for(var h=new Array(arguments.length-1),e=0;e<h.length;e++)h[e]=arguments[e+1];var s={callback:T,args:h};return m[g]=s,t(g),g++}function a(T){delete m[T]}function w(T){var h=T.callback,e=T.args;switch(e.length){case 0:h();break;case 1:h(e[0]);break;case 2:h(e[0],e[1]);break;case 3:h(e[0],e[1],e[2]);break;default:h.apply(r,e);break}}function N(T){if(L)setTimeout(N,0,T);else{var h=m[T];if(h){L=!0;try{w(h)}finally{a(T),L=!1}}}}function j(){t=function(T){process.nextTick(function(){N(T)})}}function u(){if(x.postMessage&&!x.importScripts){var T=!0,h=x.onmessage;return x.onmessage=function(){T=!1},x.postMessage("","*"),x.onmessage=h,T}}function c(){var T="setImmediate$"+Math.random()+"$",h=function(e){e.source===x&&typeof e.data=="string"&&e.data.indexOf(T)===0&&N(+e.data.slice(T.length))};x.addEventListener?x.addEventListener("message",h,!1):x.attachEvent("onmessage",h),t=function(e){x.postMessage(T+e,"*")}}function I(){var T=new MessageChannel;T.port1.onmessage=function(h){var e=h.data;N(e)},t=function(h){T.port2.postMessage(h)}}function _(){var T=i.documentElement;t=function(h){var e=i.createElement("script");e.onreadystatechange=function(){N(h),e.onreadystatechange=null,T.removeChild(e),e=null},T.appendChild(e)}}function O(){t=function(T){setTimeout(N,0,T)}}var J=Object.getPrototypeOf&&Object.getPrototypeOf(x);J=J&&J.setTimeout?J:x,{}.toString.call(x.process)==="[object process]"?j():u()?c():x.MessageChannel?I():i&&"onreadystatechange"in i.createElement("script")?_():O(),J.setImmediate=n,J.clearImmediate=a}(typeof self>"u"?typeof window>"u"?ve:window:self)),ve}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var be,at;function fe(){if(at)return be;at=1,Yt();const x=self.crypto||self.msCrypto;return be=class{constructor(g){if(!(x&&x.subtle))throw new Error("crypto.subtle not found.");if(g==="sha256")this.algorithm={name:"SHA-256"};else if(g==="sha1")this.algorithm={name:"SHA-1"};else throw new Error(`Unsupported algorithm "${g}".`);this._content=""}update(g){this._content+=g}async digest(){const g=new TextEncoder().encode(this._content),m=new Uint8Array(await x.subtle.digest(this.algorithm,g));let L="";for(let i=0;i<m.length;++i)L+=m[i].toString(16).padStart(2,"0");return L}},be}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var we,ot;function Ut(){return ot||(ot=1,we=class{constructor(r){this.current=r.sort(),this.done=!1,this.dir=new Map;for(let g=0;g<r.length;++g)this.dir.set(r[g],!0)}hasNext(){return!this.done}next(){const{current:r,dir:g}=this,m=r.slice();let L=null,i=0;const t=r.length;for(let n=0;n<t;++n){const a=r[n],w=g.get(a);(L===null||a>L)&&(w&&n>0&&a>r[n-1]||!w&&n<t-1&&a>r[n+1])&&(L=a,i=n)}if(L===null)this.done=!0;else{const n=g.get(L)?i-1:i+1;r[i]=r[n],r[n]=L;for(const a of r)a>L&&g.set(a,!g.get(a))}return m}}),we}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var xe,lt;function et(){if(lt)return xe;lt=1;const r="http://www.w3.org/1999/02/22-rdf-syntax-ns#"+"langString",g="http://www.w3.org/2001/XMLSchema#string",m="NamedNode",L="BlankNode",i="Literal",t="DefaultGraph",n={};(()=>{const c="(?:<([^:]+:[^>]*)>)",_="A-Za-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�"+"_",O=_+"0-9-·̀-ͯ‿-⁀",T="(_:(?:["+_+"0-9])(?:(?:["+O+".])*(?:["+O+"]))?)",h='"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"',e="(?:\\^\\^"+c+")",o="(?:"+h+"(?:"+e+"|"+"(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*))"+")?)",D="[ \\t]+",f="[ \\t]*",E="(?:"+c+"|"+T+")"+D,b=c+D,F="(?:"+c+"|"+T+"|"+o+")"+f,p="(?:\\.|(?:(?:"+c+"|"+T+")"+f+"\\.))";n.eoln=/(?:\r\n)|(?:\n)|(?:\r)/g,n.empty=new RegExp("^"+f+"$"),n.quad=new RegExp("^"+f+E+b+F+p+f+"$")})(),xe=class de{static parse(I){const _=[],O={},J=I.split(n.eoln);let T=0;for(const h of J){if(T++,n.empty.test(h))continue;const e=h.match(n.quad);if(e===null)throw new Error("N-Quads parse error on line "+T+".");const s={subject:null,predicate:null,object:null,graph:null};if(e[1]!==void 0?s.subject={termType:m,value:e[1]}:s.subject={termType:L,value:e[2]},s.predicate={termType:m,value:e[3]},e[4]!==void 0?s.object={termType:m,value:e[4]}:e[5]!==void 0?s.object={termType:L,value:e[5]}:(s.object={termType:i,value:void 0,datatype:{termType:m}},e[7]!==void 0?s.object.datatype.value=e[7]:e[8]!==void 0?(s.object.datatype.value=r,s.object.language=e[8]):s.object.datatype.value=g,s.object.value=u(e[6])),e[9]!==void 0?s.graph={termType:m,value:e[9]}:e[10]!==void 0?s.graph={termType:L,value:e[10]}:s.graph={termType:t,value:""},!(s.graph.value in O))O[s.graph.value]=[s],_.push(s);else{let o=!0;const D=O[s.graph.value];for(const f of D)if(a(f,s)){o=!1;break}o&&(D.push(s),_.push(s))}}return _}static serialize(I){Array.isArray(I)||(I=de.legacyDatasetToQuads(I));const _=[];for(const O of I)_.push(de.serializeQuad(O));return _.sort().join("")}static serializeQuadComponents(I,_,O,J){let T="";return I.termType===m?T+=`<${I.value}>`:T+=`${I.value}`,T+=` <${_.value}> `,O.termType===m?T+=`<${O.value}>`:O.termType===L?T+=O.value:(T+=`"${N(O.value)}"`,O.datatype.value===r?O.language&&(T+=`@${O.language}`):O.datatype.value!==g&&(T+=`^^<${O.datatype.value}>`)),J.termType===m?T+=` <${J.value}>`:J.termType===L&&(T+=` ${J.value}`),T+=` .
`,T}static serializeQuad(I){return de.serializeQuadComponents(I.subject,I.predicate,I.object,I.graph)}static legacyDatasetToQuads(I){const _=[],O={"blank node":L,IRI:m,literal:i};for(const J in I)I[J].forEach(h=>{const e={};for(const s in h){const o=h[s],D={termType:O[o.type],value:o.value};D.termType===i&&(D.datatype={termType:m},"datatype"in o&&(D.datatype.value=o.datatype),"language"in o?("datatype"in o||(D.datatype.value=r),D.language=o.language):"datatype"in o||(D.datatype.value=g)),e[s]=D}J==="@default"?e.graph={termType:t,value:""}:e.graph={termType:J.startsWith("_:")?L:m,value:J},_.push(e)});return _}};function a(c,I){return!(c.subject.termType===I.subject.termType&&c.object.termType===I.object.termType)||!(c.subject.value===I.subject.value&&c.predicate.value===I.predicate.value&&c.object.value===I.object.value)?!1:c.object.termType!==i?!0:c.object.datatype.termType===I.object.datatype.termType&&c.object.language===I.object.language&&c.object.datatype.value===I.object.datatype.value}const w=/["\\\n\r]/g;function N(c){return c.replace(w,function(I){switch(I){case'"':return'\\"';case"\\":return"\\\\";case`
`:return"\\n";case"\r":return"\\r"}})}const j=/(?:\\([tbnrf"'\\]))|(?:\\u([0-9A-Fa-f]{4}))|(?:\\U([0-9A-Fa-f]{8}))/g;function u(c){return c.replace(j,function(I,_,O,J){if(_)switch(_){case"t":return"	";case"b":return"\b";case"n":return`
`;case"r":return"\r";case"f":return"\f";case'"':return'"';case"'":return"'";case"\\":return"\\"}if(O)return String.fromCharCode(parseInt(O,16));if(J)throw new Error("Unsupported U escape")})}return xe}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var Ie,ct;function Vt(){if(ct)return Ie;ct=1;const x=Ze(),r=fe(),g=Ut(),m=et();Ie=class{constructor({createMessageDigest:t=()=>new r("sha256"),canonicalIdMap:n=new Map,maxDeepIterations:a=1/0}={}){this.name="URDNA2015",this.blankNodeInfo=new Map,this.canonicalIssuer=new x("_:c14n",n),this.createMessageDigest=t,this.maxDeepIterations=a,this.quads=null,this.deepIterations=null}async main(t){this.deepIterations=new Map,this.quads=t;for(const c of t)this._addBlankNodeQuadInfo({quad:c,component:c.subject}),this._addBlankNodeQuadInfo({quad:c,component:c.object}),this._addBlankNodeQuadInfo({quad:c,component:c.graph});const n=new Map,a=[...this.blankNodeInfo.keys()];let w=0;for(const c of a)++w%100===0&&await this._yield(),await this._hashAndTrackBlankNode({id:c,hashToBlankNodes:n});const N=[...n.keys()].sort(),j=[];for(const c of N){const I=n.get(c);if(I.length>1){j.push(I);continue}const _=I[0];this.canonicalIssuer.getId(_)}for(const c of j){const I=[];for(const _ of c){if(this.canonicalIssuer.hasId(_))continue;const O=new x("_:b");O.getId(_);const J=await this.hashNDegreeQuads(_,O);I.push(J)}I.sort(L);for(const _ of I){const O=_.issuer.getOldIds();for(const J of O)this.canonicalIssuer.getId(J)}}const u=[];for(const c of this.quads){const I=m.serializeQuadComponents(this._componentWithCanonicalId(c.subject),c.predicate,this._componentWithCanonicalId(c.object),this._componentWithCanonicalId(c.graph));u.push(I)}return u.sort(),u.join("")}async hashFirstDegreeQuads(t){const n=[],a=this.blankNodeInfo.get(t),w=a.quads;for(const j of w){const u={subject:null,predicate:j.predicate,object:null,graph:null};u.subject=this.modifyFirstDegreeComponent(t,j.subject,"subject"),u.object=this.modifyFirstDegreeComponent(t,j.object,"object"),u.graph=this.modifyFirstDegreeComponent(t,j.graph,"graph"),n.push(m.serializeQuad(u))}n.sort();const N=this.createMessageDigest();for(const j of n)N.update(j);return a.hash=await N.digest(),a.hash}async hashRelatedBlankNode(t,n,a,w){let N;this.canonicalIssuer.hasId(t)?N=this.canonicalIssuer.getId(t):a.hasId(t)?N=a.getId(t):N=this.blankNodeInfo.get(t).hash;const j=this.createMessageDigest();return j.update(w),w!=="g"&&j.update(this.getRelatedPredicate(n)),j.update(N),j.digest()}async hashNDegreeQuads(t,n){const a=this.deepIterations.get(t)||0;if(a>this.maxDeepIterations)throw new Error(`Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);this.deepIterations.set(t,a+1);const w=this.createMessageDigest(),N=await this.createHashToRelated(t,n),j=[...N.keys()].sort();for(const u of j){w.update(u);let c="",I;const _=new g(N.get(u));let O=0;for(;_.hasNext();){const J=_.next();++O%3===0&&await this._yield();let T=n.clone(),h="";const e=[];let s=!1;for(const o of J)if(this.canonicalIssuer.hasId(o)?h+=this.canonicalIssuer.getId(o):(T.hasId(o)||e.push(o),h+=T.getId(o)),c.length!==0&&h>c){s=!0;break}if(!s){for(const o of e){const D=await this.hashNDegreeQuads(o,T);if(h+=T.getId(o),h+=`<${D.hash}>`,T=D.issuer,c.length!==0&&h>c){s=!0;break}}s||(c.length===0||h<c)&&(c=h,I=T)}}w.update(c),n=I}return{hash:await w.digest(),issuer:n}}modifyFirstDegreeComponent(t,n){return n.termType!=="BlankNode"?n:{termType:"BlankNode",value:n.value===t?"_:a":"_:z"}}getRelatedPredicate(t){return`<${t.predicate.value}>`}async createHashToRelated(t,n){const a=new Map,w=this.blankNodeInfo.get(t).quads;let N=0;for(const j of w)++N%100===0&&await this._yield(),await Promise.all([this._addRelatedBlankNodeHash({quad:j,component:j.subject,position:"s",id:t,issuer:n,hashToRelated:a}),this._addRelatedBlankNodeHash({quad:j,component:j.object,position:"o",id:t,issuer:n,hashToRelated:a}),this._addRelatedBlankNodeHash({quad:j,component:j.graph,position:"g",id:t,issuer:n,hashToRelated:a})]);return a}async _hashAndTrackBlankNode({id:t,hashToBlankNodes:n}){const a=await this.hashFirstDegreeQuads(t),w=n.get(a);w?w.push(t):n.set(a,[t])}_addBlankNodeQuadInfo({quad:t,component:n}){if(n.termType!=="BlankNode")return;const a=n.value,w=this.blankNodeInfo.get(a);w?w.quads.add(t):this.blankNodeInfo.set(a,{quads:new Set([t]),hash:null})}async _addRelatedBlankNodeHash({quad:t,component:n,position:a,id:w,issuer:N,hashToRelated:j}){if(!(n.termType==="BlankNode"&&n.value!==w))return;const u=n.value,c=await this.hashRelatedBlankNode(u,t,N,a),I=j.get(c);I?I.push(u):j.set(c,[u])}_componentWithCanonicalId(t){return t.termType==="BlankNode"&&!t.value.startsWith(this.canonicalIssuer.prefix)?{termType:"BlankNode",value:this.canonicalIssuer.getId(t.value)}:t}async _yield(){return new Promise(t=>setImmediate(t))}};function L(i,t){return i.hash<t.hash?-1:i.hash>t.hash?1:0}return Ie}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var Ne,ut;function Zt(){if(ut)return Ne;ut=1;const x=fe(),r=Vt();return Ne=class extends r{constructor(){super(),this.name="URGNA2012",this.createMessageDigest=()=>new x("sha1")}modifyFirstDegreeComponent(m,L,i){return L.termType!=="BlankNode"?L:i==="graph"?{termType:"BlankNode",value:"_:g"}:{termType:"BlankNode",value:L.value===m?"_:a":"_:z"}}getRelatedPredicate(m){return m.predicate.value}async createHashToRelated(m,L){const i=new Map,t=this.blankNodeInfo.get(m).quads;let n=0;for(const a of t){let w,N;if(a.subject.termType==="BlankNode"&&a.subject.value!==m)N=a.subject.value,w="p";else if(a.object.termType==="BlankNode"&&a.object.value!==m)N=a.object.value,w="r";else continue;++n%100===0&&await this._yield();const j=await this.hashRelatedBlankNode(N,a,L,w),u=i.get(j);u?u.push(N):i.set(j,[N])}return i}},Ne}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var Ee,dt;function Gt(){if(dt)return Ee;dt=1;const x=Ze(),r=fe(),g=Ut(),m=et();Ee=class{constructor({createMessageDigest:t=()=>new r("sha256"),canonicalIdMap:n=new Map,maxDeepIterations:a=1/0}={}){this.name="URDNA2015",this.blankNodeInfo=new Map,this.canonicalIssuer=new x("_:c14n",n),this.createMessageDigest=t,this.maxDeepIterations=a,this.quads=null,this.deepIterations=null}main(t){this.deepIterations=new Map,this.quads=t;for(const u of t)this._addBlankNodeQuadInfo({quad:u,component:u.subject}),this._addBlankNodeQuadInfo({quad:u,component:u.object}),this._addBlankNodeQuadInfo({quad:u,component:u.graph});const n=new Map,a=[...this.blankNodeInfo.keys()];for(const u of a)this._hashAndTrackBlankNode({id:u,hashToBlankNodes:n});const w=[...n.keys()].sort(),N=[];for(const u of w){const c=n.get(u);if(c.length>1){N.push(c);continue}const I=c[0];this.canonicalIssuer.getId(I)}for(const u of N){const c=[];for(const I of u){if(this.canonicalIssuer.hasId(I))continue;const _=new x("_:b");_.getId(I);const O=this.hashNDegreeQuads(I,_);c.push(O)}c.sort(L);for(const I of c){const _=I.issuer.getOldIds();for(const O of _)this.canonicalIssuer.getId(O)}}const j=[];for(const u of this.quads){const c=m.serializeQuadComponents(this._componentWithCanonicalId({component:u.subject}),u.predicate,this._componentWithCanonicalId({component:u.object}),this._componentWithCanonicalId({component:u.graph}));j.push(c)}return j.sort(),j.join("")}hashFirstDegreeQuads(t){const n=[],a=this.blankNodeInfo.get(t),w=a.quads;for(const j of w){const u={subject:null,predicate:j.predicate,object:null,graph:null};u.subject=this.modifyFirstDegreeComponent(t,j.subject,"subject"),u.object=this.modifyFirstDegreeComponent(t,j.object,"object"),u.graph=this.modifyFirstDegreeComponent(t,j.graph,"graph"),n.push(m.serializeQuad(u))}n.sort();const N=this.createMessageDigest();for(const j of n)N.update(j);return a.hash=N.digest(),a.hash}hashRelatedBlankNode(t,n,a,w){let N;this.canonicalIssuer.hasId(t)?N=this.canonicalIssuer.getId(t):a.hasId(t)?N=a.getId(t):N=this.blankNodeInfo.get(t).hash;const j=this.createMessageDigest();return j.update(w),w!=="g"&&j.update(this.getRelatedPredicate(n)),j.update(N),j.digest()}hashNDegreeQuads(t,n){const a=this.deepIterations.get(t)||0;if(a>this.maxDeepIterations)throw new Error(`Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);this.deepIterations.set(t,a+1);const w=this.createMessageDigest(),N=this.createHashToRelated(t,n),j=[...N.keys()].sort();for(const u of j){w.update(u);let c="",I;const _=new g(N.get(u));for(;_.hasNext();){const O=_.next();let J=n.clone(),T="";const h=[];let e=!1;for(const s of O)if(this.canonicalIssuer.hasId(s)?T+=this.canonicalIssuer.getId(s):(J.hasId(s)||h.push(s),T+=J.getId(s)),c.length!==0&&T>c){e=!0;break}if(!e){for(const s of h){const o=this.hashNDegreeQuads(s,J);if(T+=J.getId(s),T+=`<${o.hash}>`,J=o.issuer,c.length!==0&&T>c){e=!0;break}}e||(c.length===0||T<c)&&(c=T,I=J)}}w.update(c),n=I}return{hash:w.digest(),issuer:n}}modifyFirstDegreeComponent(t,n){return n.termType!=="BlankNode"?n:{termType:"BlankNode",value:n.value===t?"_:a":"_:z"}}getRelatedPredicate(t){return`<${t.predicate.value}>`}createHashToRelated(t,n){const a=new Map,w=this.blankNodeInfo.get(t).quads;for(const N of w)this._addRelatedBlankNodeHash({quad:N,component:N.subject,position:"s",id:t,issuer:n,hashToRelated:a}),this._addRelatedBlankNodeHash({quad:N,component:N.object,position:"o",id:t,issuer:n,hashToRelated:a}),this._addRelatedBlankNodeHash({quad:N,component:N.graph,position:"g",id:t,issuer:n,hashToRelated:a});return a}_hashAndTrackBlankNode({id:t,hashToBlankNodes:n}){const a=this.hashFirstDegreeQuads(t),w=n.get(a);w?w.push(t):n.set(a,[t])}_addBlankNodeQuadInfo({quad:t,component:n}){if(n.termType!=="BlankNode")return;const a=n.value,w=this.blankNodeInfo.get(a);w?w.quads.add(t):this.blankNodeInfo.set(a,{quads:new Set([t]),hash:null})}_addRelatedBlankNodeHash({quad:t,component:n,position:a,id:w,issuer:N,hashToRelated:j}){if(!(n.termType==="BlankNode"&&n.value!==w))return;const u=n.value,c=this.hashRelatedBlankNode(u,t,N,a),I=j.get(c);I?I.push(u):j.set(c,[u])}_componentWithCanonicalId({component:t}){return t.termType==="BlankNode"&&!t.value.startsWith(this.canonicalIssuer.prefix)?{termType:"BlankNode",value:this.canonicalIssuer.getId(t.value)}:t}};function L(i,t){return i.hash<t.hash?-1:i.hash>t.hash?1:0}return Ee}/*!
 * Copyright (c) 2016-2021 Digital Bazaar, Inc. All rights reserved.
 */var _e,ft;function en(){if(ft)return _e;ft=1;const x=fe(),r=Gt();return _e=class extends r{constructor(){super(),this.name="URGNA2012",this.createMessageDigest=()=>new x("sha1")}modifyFirstDegreeComponent(m,L,i){return L.termType!=="BlankNode"?L:i==="graph"?{termType:"BlankNode",value:"_:g"}:{termType:"BlankNode",value:L.value===m?"_:a":"_:z"}}getRelatedPredicate(m){return m.predicate.value}createHashToRelated(m,L){const i=new Map,t=this.blankNodeInfo.get(m).quads;for(const n of t){let a,w;if(n.subject.termType==="BlankNode"&&n.subject.value!==m)w=n.subject.value,a="p";else if(n.object.termType==="BlankNode"&&n.object.value!==m)w=n.object.value,a="r";else continue;const N=this.hashRelatedBlankNode(w,n,L,a),j=i.get(N);j?j.push(w):i.set(N,[w])}return i}},_e}var ht;function tn(){return ht||(ht=1,function(x){const r=Vt(),g=Zt(),m=Gt(),L=en();let i;try{i=Xt}catch{}function t(n){return Array.isArray(n)?n:x.NQuads.legacyDatasetToQuads(n)}x.NQuads=et(),x.IdentifierIssuer=Ze(),x._rdfCanonizeNative=function(n){return n&&(i=n),i},x.canonize=async function(n,a){const w=t(n);if(a.useNative){if(!i)throw new Error("rdf-canonize-native not available");if(a.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "useNative".');return new Promise((N,j)=>i.canonize(w,a,(u,c)=>u?j(u):N(c)))}if(a.algorithm==="URDNA2015")return new r(a).main(w);if(a.algorithm==="URGNA2012"){if(a.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "URGNA2012".');return new g(a).main(w)}throw"algorithm"in a?new Error("Invalid RDF Dataset Canonicalization algorithm: "+a.algorithm):new Error("No RDF Dataset Canonicalization algorithm specified.")},x._canonizeSync=function(n,a){const w=t(n);if(a.useNative){if(!i)throw new Error("rdf-canonize-native not available");if(a.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "useNative".');return i.canonizeSync(w,a)}if(a.algorithm==="URDNA2015")return new m(a).main(w);if(a.algorithm==="URGNA2012"){if(a.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "URGNA2012".');return new L(a).main(w)}throw"algorithm"in a?new Error("Invalid RDF Dataset Canonicalization algorithm: "+a.algorithm):new Error("No RDF Dataset Canonicalization algorithm specified.")}}(ye)),ye}var je,pt;function tt(){return pt||(pt=1,je=tn()),je}var Se,gt;function ee(){if(gt)return Se;gt=1;const x={};return Se=x,x.isArray=Array.isArray,x.isBoolean=r=>typeof r=="boolean"||Object.prototype.toString.call(r)==="[object Boolean]",x.isDouble=r=>x.isNumber(r)&&(String(r).indexOf(".")!==-1||Math.abs(r)>=1e21),x.isEmptyObject=r=>x.isObject(r)&&Object.keys(r).length===0,x.isNumber=r=>typeof r=="number"||Object.prototype.toString.call(r)==="[object Number]",x.isNumeric=r=>!isNaN(parseFloat(r))&&isFinite(r),x.isObject=r=>Object.prototype.toString.call(r)==="[object Object]",x.isString=r=>typeof r=="string"||Object.prototype.toString.call(r)==="[object String]",x.isUndefined=r=>typeof r>"u",Se}var Re,yt;function re(){if(yt)return Re;yt=1;const x=ee(),r={};return Re=r,r.isSubject=g=>x.isObject(g)&&!("@value"in g||"@set"in g||"@list"in g)?Object.keys(g).length>1||!("@id"in g):!1,r.isSubjectReference=g=>x.isObject(g)&&Object.keys(g).length===1&&"@id"in g,r.isValue=g=>x.isObject(g)&&"@value"in g,r.isList=g=>x.isObject(g)&&"@list"in g,r.isGraph=g=>x.isObject(g)&&"@graph"in g&&Object.keys(g).filter(m=>m!=="@id"&&m!=="@index").length===1,r.isSimpleGraph=g=>r.isGraph(g)&&!("@id"in g),r.isBlankNode=g=>{if(x.isObject(g)){if("@id"in g){const m=g["@id"];return!x.isString(m)||m.indexOf("_:")===0}return Object.keys(g).length===0||!("@value"in g||"@set"in g||"@list"in g)}return!1},Re}var De,mt;function ne(){return mt||(mt=1,De=class extends Error{constructor(r="An unspecified JSON-LD error occurred.",g="jsonld.Error",m={}){super(r),this.name=g,this.message=r,this.details=m}}),De}var Oe,vt;function te(){if(vt)return Oe;vt=1;const x=re(),r=ee(),g=tt().IdentifierIssuer,m=ne(),L=/^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/,i=/(?:<[^>]*?>|"[^"]*?"|[^,])+/g,t=/\s*<([^>]*?)>\s*(?:;\s*(.*))?/,n=/(.*?)=(?:(?:"([^"]*?)")|([^"]*?))\s*(?:(?:;\s*)|$)/g,a=/^@[a-zA-Z]+$/,w={headers:{accept:"application/ld+json, application/json"}},N={};Oe=N,N.IdentifierIssuer=g,N.REGEX_BCP47=L,N.REGEX_KEYWORD=a,N.clone=function(u){if(u&&typeof u=="object"){let c;if(r.isArray(u)){c=[];for(let I=0;I<u.length;++I)c[I]=N.clone(u[I])}else if(u instanceof Map){c=new Map;for(const[I,_]of u)c.set(I,N.clone(_))}else if(u instanceof Set){c=new Set;for(const I of u)c.add(N.clone(I))}else if(r.isObject(u)){c={};for(const I in u)c[I]=N.clone(u[I])}else c=u.toString();return c}return u},N.asArray=function(u){return Array.isArray(u)?u:[u]},N.buildHeaders=(u={})=>{if(Object.keys(u).some(I=>I.toLowerCase()==="accept"))throw new RangeError('Accept header may not be specified; only "'+w.headers.accept+'" is supported.');return Object.assign({Accept:w.headers.accept},u)},N.parseLinkHeader=u=>{const c={},I=u.match(i);for(let _=0;_<I.length;++_){let O=I[_].match(t);if(!O)continue;const J={target:O[1]},T=O[2];for(;O=n.exec(T);)J[O[1]]=O[2]===void 0?O[3]:O[2];const h=J.rel||"";Array.isArray(c[h])?c[h].push(J):c.hasOwnProperty(h)?c[h]=[c[h],J]:c[h]=J}return c},N.validateTypeValue=(u,c)=>{if(!r.isString(u)&&!(r.isArray(u)&&u.every(I=>r.isString(I)))){if(c&&r.isObject(u))switch(Object.keys(u).length){case 0:return;case 1:if("@default"in u&&N.asArray(u["@default"]).every(I=>r.isString(I)))return}throw new m('Invalid JSON-LD syntax; "@type" value must a string, an array of strings, an empty object, or a default object.',"jsonld.SyntaxError",{code:"invalid type value",value:u})}},N.hasProperty=(u,c)=>{if(u.hasOwnProperty(c)){const I=u[c];return!r.isArray(I)||I.length>0}return!1},N.hasValue=(u,c,I)=>{if(N.hasProperty(u,c)){let _=u[c];const O=x.isList(_);if(r.isArray(_)||O){O&&(_=_["@list"]);for(let J=0;J<_.length;++J)if(N.compareValues(I,_[J]))return!0}else if(!r.isArray(I))return N.compareValues(I,_)}return!1},N.addValue=(u,c,I,_)=>{if(_=_||{},"propertyIsArray"in _||(_.propertyIsArray=!1),"valueIsArray"in _||(_.valueIsArray=!1),"allowDuplicate"in _||(_.allowDuplicate=!0),"prependValue"in _||(_.prependValue=!1),_.valueIsArray)u[c]=I;else if(r.isArray(I)){I.length===0&&_.propertyIsArray&&!u.hasOwnProperty(c)&&(u[c]=[]),_.prependValue&&(I=I.concat(u[c]),u[c]=[]);for(let O=0;O<I.length;++O)N.addValue(u,c,I[O],_)}else if(u.hasOwnProperty(c)){const O=!_.allowDuplicate&&N.hasValue(u,c,I);!r.isArray(u[c])&&(!O||_.propertyIsArray)&&(u[c]=[u[c]]),O||(_.prependValue?u[c].unshift(I):u[c].push(I))}else u[c]=_.propertyIsArray?[I]:I},N.getValues=(u,c)=>[].concat(u[c]||[]),N.removeProperty=(u,c)=>{delete u[c]},N.removeValue=(u,c,I,_)=>{_=_||{},"propertyIsArray"in _||(_.propertyIsArray=!1);const O=N.getValues(u,c).filter(J=>!N.compareValues(J,I));O.length===0?N.removeProperty(u,c):O.length===1&&!_.propertyIsArray?u[c]=O[0]:u[c]=O},N.relabelBlankNodes=(u,c)=>{c=c||{};const I=c.issuer||new g("_:b");return j(I,u)},N.compareValues=(u,c)=>u===c||x.isValue(u)&&x.isValue(c)&&u["@value"]===c["@value"]&&u["@type"]===c["@type"]&&u["@language"]===c["@language"]&&u["@index"]===c["@index"]?!0:r.isObject(u)&&"@id"in u&&r.isObject(c)&&"@id"in c?u["@id"]===c["@id"]:!1,N.compareShortestLeast=(u,c)=>u.length<c.length?-1:c.length<u.length?1:u===c?0:u<c?-1:1;function j(u,c){if(r.isArray(c))for(let I=0;I<c.length;++I)c[I]=j(u,c[I]);else if(x.isList(c))c["@list"]=j(u,c["@list"]);else if(r.isObject(c)){x.isBlankNode(c)&&(c["@id"]=u.getId(c["@id"]));const I=Object.keys(c).sort();for(let _=0;_<I.length;++_){const O=I[_];O!=="@id"&&(c[O]=j(u,c[O]))}}return c}return Oe}var Le,bt;function nt(){if(bt)return Le;bt=1;const x="http://www.w3.org/1999/02/22-rdf-syntax-ns#",r="http://www.w3.org/2001/XMLSchema#";return Le={LINK_HEADER_REL:"http://www.w3.org/ns/json-ld#context",LINK_HEADER_CONTEXT:"http://www.w3.org/ns/json-ld#context",RDF:x,RDF_LIST:x+"List",RDF_FIRST:x+"first",RDF_REST:x+"rest",RDF_NIL:x+"nil",RDF_TYPE:x+"type",RDF_PLAIN_LITERAL:x+"PlainLiteral",RDF_XML_LITERAL:x+"XMLLiteral",RDF_JSON_LITERAL:x+"JSON",RDF_OBJECT:x+"object",RDF_LANGSTRING:x+"langString",XSD:r,XSD_BOOLEAN:r+"boolean",XSD_DOUBLE:r+"double",XSD_INTEGER:r+"integer",XSD_STRING:r+"string"},Le}var Ae,wt;function $t(){return wt||(wt=1,Ae=class{constructor(){this._requests={}}wrapLoader(r){const g=this;return g._loader=r,function(){return g.add.apply(g,arguments)}}async add(r){let g=this._requests[r];if(g)return Promise.resolve(g);g=this._requests[r]=this._loader(r);try{return await g}finally{delete this._requests[r]}}}),Ae}var Te,xt;function se(){if(xt)return Te;xt=1;const x=ee(),r={};Te=r,r.parsers={simple:{keys:["href","scheme","authority","path","query","fragment"],regex:/^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/},full:{keys:["href","protocol","scheme","authority","auth","user","password","hostname","port","path","directory","file","query","fragment"],regex:/^(([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?(?:(((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/}},r.parse=(m,L)=>{const i={},t=r.parsers[L||"full"],n=t.regex.exec(m);let a=t.keys.length;for(;a--;)i[t.keys[a]]=n[a]===void 0?null:n[a];return(i.scheme==="https"&&i.port==="443"||i.scheme==="http"&&i.port==="80")&&(i.href=i.href.replace(":"+i.port,""),i.authority=i.authority.replace(":"+i.port,""),i.port=null),i.normalizedPath=r.removeDotSegments(i.path),i},r.prependBase=(m,L)=>{if(m===null||r.isAbsolute(L))return L;(!m||x.isString(m))&&(m=r.parse(m||""));const i=r.parse(L),t={protocol:m.protocol||""};if(i.authority!==null)t.authority=i.authority,t.path=i.path,t.query=i.query;else if(t.authority=m.authority,i.path==="")t.path=m.path,i.query!==null?t.query=i.query:t.query=m.query;else{if(i.path.indexOf("/")===0)t.path=i.path;else{let a=m.path;a=a.substr(0,a.lastIndexOf("/")+1),(a.length>0||m.authority)&&a.substr(-1)!=="/"&&(a+="/"),a+=i.path,t.path=a}t.query=i.query}i.path!==""&&(t.path=r.removeDotSegments(t.path));let n=t.protocol;return t.authority!==null&&(n+="//"+t.authority),n+=t.path,t.query!==null&&(n+="?"+t.query),i.fragment!==null&&(n+="#"+i.fragment),n===""&&(n="./"),n},r.removeBase=(m,L)=>{if(m===null)return L;(!m||x.isString(m))&&(m=r.parse(m||""));let i="";if(m.href!==""?i+=(m.protocol||"")+"//"+(m.authority||""):L.indexOf("//")&&(i+="//"),L.indexOf(i)!==0)return L;const t=r.parse(L.substr(i.length)),n=m.normalizedPath.split("/"),a=t.normalizedPath.split("/"),w=t.fragment||t.query?0:1;for(;n.length>0&&a.length>w&&n[0]===a[0];)n.shift(),a.shift();let N="";if(n.length>0){n.pop();for(let j=0;j<n.length;++j)N+="../"}return N+=a.join("/"),t.query!==null&&(N+="?"+t.query),t.fragment!==null&&(N+="#"+t.fragment),N===""&&(N="./"),N},r.removeDotSegments=m=>{if(m.length===0)return"";const L=m.split("/"),i=[];for(;L.length>0;){const t=L.shift(),n=L.length===0;if(t==="."){n&&i.push("");continue}if(t===".."){i.pop(),n&&i.push("");continue}i.push(t)}return m[0]==="/"&&i.length>0&&i[0]!==""&&i.unshift(""),i.length===1&&i[0]===""?"/":i.join("/")};const g=/^([A-Za-z][A-Za-z0-9+-.]*|_):[^\s]*$/;return r.isAbsolute=m=>x.isString(m)&&g.test(m),r.isRelative=m=>x.isString(m),Te}var ke,It;function nn(){if(It)return ke;It=1;const{parseLinkHeader:x,buildHeaders:r}=te(),{LINK_HEADER_CONTEXT:g}=nt(),m=ne(),L=$t(),{prependBase:i}=se(),t=/(^|(\r\n))link:/i;ke=({secure:a,headers:w={},xhr:N}={headers:{}})=>{return w=r(w),new L().wrapLoader(u);async function u(c){if(c.indexOf("http:")!==0&&c.indexOf("https:")!==0)throw new m('URL could not be dereferenced; only "http" and "https" URLs are supported.',"jsonld.InvalidUrl",{code:"loading document failed",url:c});if(a&&c.indexOf("https")!==0)throw new m(`URL could not be dereferenced; secure mode is enabled and the URL's scheme is not "https".`,"jsonld.InvalidUrl",{code:"loading document failed",url:c});let I;try{I=await n(N,c,w)}catch(h){throw new m("URL could not be dereferenced, an error occurred.","jsonld.LoadDocumentError",{code:"loading document failed",url:c,cause:h})}if(I.status>=400)throw new m("URL could not be dereferenced: "+I.statusText,"jsonld.LoadDocumentError",{code:"loading document failed",url:c,httpStatusCode:I.status});let _={contextUrl:null,documentUrl:c,document:I.response},O=null;const J=I.getResponseHeader("Content-Type");let T;if(t.test(I.getAllResponseHeaders())&&(T=I.getResponseHeader("Link")),T&&J!=="application/ld+json"){const h=x(T),e=h[g];if(Array.isArray(e))throw new m("URL could not be dereferenced, it has more than one associated HTTP Link Header.","jsonld.InvalidUrl",{code:"multiple context link headers",url:c});e&&(_.contextUrl=e.target),O=h.alternate,O&&O.type=="application/ld+json"&&!(J||"").match(/^application\/(\w*\+)?json$/)&&(_=await u(i(c,O.target)))}return _}};function n(a,w,N){a=a||XMLHttpRequest;const j=new a;return new Promise((u,c)=>{j.onload=()=>u(j),j.onerror=I=>c(I),j.open("GET",w,!0);for(const I in N)j.setRequestHeader(I,N[I]);j.send()})}return ke}var Me,Nt;function rn(){if(Nt)return Me;Nt=1;const x=nn(),r={};return Me=r,r.setupDocumentLoaders=function(g){typeof XMLHttpRequest<"u"&&(g.documentLoaders.xhr=x,g.useDocumentLoader("xhr"))},r.setupGlobals=function(g){typeof globalThis.JsonLdProcessor>"u"&&Object.defineProperty(globalThis,"JsonLdProcessor",{writable:!0,enumerable:!1,configurable:!0,value:g.JsonLdProcessor})},Me}var qe,Et;function sn(){return Et||(Et=1,qe=function(x){x.prototype[Symbol.iterator]=function*(){for(let r=this.head;r;r=r.next)yield r.value}}),qe}var Je,_t;function an(){if(_t)return Je;_t=1,Je=x,x.Node=L,x.create=x;function x(i){var t=this;if(t instanceof x||(t=new x),t.tail=null,t.head=null,t.length=0,i&&typeof i.forEach=="function")i.forEach(function(w){t.push(w)});else if(arguments.length>0)for(var n=0,a=arguments.length;n<a;n++)t.push(arguments[n]);return t}x.prototype.removeNode=function(i){if(i.list!==this)throw new Error("removing node which does not belong to this list");var t=i.next,n=i.prev;return t&&(t.prev=n),n&&(n.next=t),i===this.head&&(this.head=t),i===this.tail&&(this.tail=n),i.list.length--,i.next=null,i.prev=null,i.list=null,t},x.prototype.unshiftNode=function(i){if(i!==this.head){i.list&&i.list.removeNode(i);var t=this.head;i.list=this,i.next=t,t&&(t.prev=i),this.head=i,this.tail||(this.tail=i),this.length++}},x.prototype.pushNode=function(i){if(i!==this.tail){i.list&&i.list.removeNode(i);var t=this.tail;i.list=this,i.prev=t,t&&(t.next=i),this.tail=i,this.head||(this.head=i),this.length++}},x.prototype.push=function(){for(var i=0,t=arguments.length;i<t;i++)g(this,arguments[i]);return this.length},x.prototype.unshift=function(){for(var i=0,t=arguments.length;i<t;i++)m(this,arguments[i]);return this.length},x.prototype.pop=function(){if(this.tail){var i=this.tail.value;return this.tail=this.tail.prev,this.tail?this.tail.next=null:this.head=null,this.length--,i}},x.prototype.shift=function(){if(this.head){var i=this.head.value;return this.head=this.head.next,this.head?this.head.prev=null:this.tail=null,this.length--,i}},x.prototype.forEach=function(i,t){t=t||this;for(var n=this.head,a=0;n!==null;a++)i.call(t,n.value,a,this),n=n.next},x.prototype.forEachReverse=function(i,t){t=t||this;for(var n=this.tail,a=this.length-1;n!==null;a--)i.call(t,n.value,a,this),n=n.prev},x.prototype.get=function(i){for(var t=0,n=this.head;n!==null&&t<i;t++)n=n.next;if(t===i&&n!==null)return n.value},x.prototype.getReverse=function(i){for(var t=0,n=this.tail;n!==null&&t<i;t++)n=n.prev;if(t===i&&n!==null)return n.value},x.prototype.map=function(i,t){t=t||this;for(var n=new x,a=this.head;a!==null;)n.push(i.call(t,a.value,this)),a=a.next;return n},x.prototype.mapReverse=function(i,t){t=t||this;for(var n=new x,a=this.tail;a!==null;)n.push(i.call(t,a.value,this)),a=a.prev;return n},x.prototype.reduce=function(i,t){var n,a=this.head;if(arguments.length>1)n=t;else if(this.head)a=this.head.next,n=this.head.value;else throw new TypeError("Reduce of empty list with no initial value");for(var w=0;a!==null;w++)n=i(n,a.value,w),a=a.next;return n},x.prototype.reduceReverse=function(i,t){var n,a=this.tail;if(arguments.length>1)n=t;else if(this.tail)a=this.tail.prev,n=this.tail.value;else throw new TypeError("Reduce of empty list with no initial value");for(var w=this.length-1;a!==null;w--)n=i(n,a.value,w),a=a.prev;return n},x.prototype.toArray=function(){for(var i=new Array(this.length),t=0,n=this.head;n!==null;t++)i[t]=n.value,n=n.next;return i},x.prototype.toArrayReverse=function(){for(var i=new Array(this.length),t=0,n=this.tail;n!==null;t++)i[t]=n.value,n=n.prev;return i},x.prototype.slice=function(i,t){t=t||this.length,t<0&&(t+=this.length),i=i||0,i<0&&(i+=this.length);var n=new x;if(t<i||t<0)return n;i<0&&(i=0),t>this.length&&(t=this.length);for(var a=0,w=this.head;w!==null&&a<i;a++)w=w.next;for(;w!==null&&a<t;a++,w=w.next)n.push(w.value);return n},x.prototype.sliceReverse=function(i,t){t=t||this.length,t<0&&(t+=this.length),i=i||0,i<0&&(i+=this.length);var n=new x;if(t<i||t<0)return n;i<0&&(i=0),t>this.length&&(t=this.length);for(var a=this.length,w=this.tail;w!==null&&a>t;a--)w=w.prev;for(;w!==null&&a>i;a--,w=w.prev)n.push(w.value);return n},x.prototype.splice=function(i,t,...n){i>this.length&&(i=this.length-1),i<0&&(i=this.length+i);for(var a=0,w=this.head;w!==null&&a<i;a++)w=w.next;for(var N=[],a=0;w&&a<t;a++)N.push(w.value),w=this.removeNode(w);w===null&&(w=this.tail),w!==this.head&&w!==this.tail&&(w=w.prev);for(var a=0;a<n.length;a++)w=r(this,w,n[a]);return N},x.prototype.reverse=function(){for(var i=this.head,t=this.tail,n=i;n!==null;n=n.prev){var a=n.prev;n.prev=n.next,n.next=a}return this.head=t,this.tail=i,this};function r(i,t,n){var a=t===i.head?new L(n,null,t,i):new L(n,t,t.next,i);return a.next===null&&(i.tail=a),a.prev===null&&(i.head=a),i.length++,a}function g(i,t){i.tail=new L(t,i.tail,null,i),i.head||(i.head=i.tail),i.length++}function m(i,t){i.head=new L(t,null,i.head,i),i.tail||(i.tail=i.head),i.length++}function L(i,t,n,a){if(!(this instanceof L))return new L(i,t,n,a);this.list=a,this.value=i,t?(t.next=this,this.prev=t):this.prev=null,n?(n.prev=this,this.next=n):this.next=null}try{sn()(x)}catch{}return Je}var Fe,jt;function zt(){if(jt)return Fe;jt=1;const x=an(),r=Symbol("max"),g=Symbol("length"),m=Symbol("lengthCalculator"),L=Symbol("allowStale"),i=Symbol("maxAge"),t=Symbol("dispose"),n=Symbol("noDisposeOnSet"),a=Symbol("lruList"),w=Symbol("cache"),N=Symbol("updateAgeOnGet"),j=()=>1;class u{constructor(e){if(typeof e=="number"&&(e={max:e}),e||(e={}),e.max&&(typeof e.max!="number"||e.max<0))throw new TypeError("max must be a non-negative number");this[r]=e.max||1/0;const s=e.length||j;if(this[m]=typeof s!="function"?j:s,this[L]=e.stale||!1,e.maxAge&&typeof e.maxAge!="number")throw new TypeError("maxAge must be a number");this[i]=e.maxAge||0,this[t]=e.dispose,this[n]=e.noDisposeOnSet||!1,this[N]=e.updateAgeOnGet||!1,this.reset()}set max(e){if(typeof e!="number"||e<0)throw new TypeError("max must be a non-negative number");this[r]=e||1/0,_(this)}get max(){return this[r]}set allowStale(e){this[L]=!!e}get allowStale(){return this[L]}set maxAge(e){if(typeof e!="number")throw new TypeError("maxAge must be a non-negative number");this[i]=e,_(this)}get maxAge(){return this[i]}set lengthCalculator(e){typeof e!="function"&&(e=j),e!==this[m]&&(this[m]=e,this[g]=0,this[a].forEach(s=>{s.length=this[m](s.value,s.key),this[g]+=s.length})),_(this)}get lengthCalculator(){return this[m]}get length(){return this[g]}get itemCount(){return this[a].length}rforEach(e,s){s=s||this;for(let o=this[a].tail;o!==null;){const D=o.prev;T(this,e,o,s),o=D}}forEach(e,s){s=s||this;for(let o=this[a].head;o!==null;){const D=o.next;T(this,e,o,s),o=D}}keys(){return this[a].toArray().map(e=>e.key)}values(){return this[a].toArray().map(e=>e.value)}reset(){this[t]&&this[a]&&this[a].length&&this[a].forEach(e=>this[t](e.key,e.value)),this[w]=new Map,this[a]=new x,this[g]=0}dump(){return this[a].map(e=>I(this,e)?!1:{k:e.key,v:e.value,e:e.now+(e.maxAge||0)}).toArray().filter(e=>e)}dumpLru(){return this[a]}set(e,s,o){if(o=o||this[i],o&&typeof o!="number")throw new TypeError("maxAge must be a number");const D=o?Date.now():0,f=this[m](s,e);if(this[w].has(e)){if(f>this[r])return O(this,this[w].get(e)),!1;const F=this[w].get(e).value;return this[t]&&(this[n]||this[t](e,F.value)),F.now=D,F.maxAge=o,F.value=s,this[g]+=f-F.length,F.length=f,this.get(e),_(this),!0}const E=new J(e,s,f,D,o);return E.length>this[r]?(this[t]&&this[t](e,s),!1):(this[g]+=E.length,this[a].unshift(E),this[w].set(e,this[a].head),_(this),!0)}has(e){if(!this[w].has(e))return!1;const s=this[w].get(e).value;return!I(this,s)}get(e){return c(this,e,!0)}peek(e){return c(this,e,!1)}pop(){const e=this[a].tail;return e?(O(this,e),e.value):null}del(e){O(this,this[w].get(e))}load(e){this.reset();const s=Date.now();for(let o=e.length-1;o>=0;o--){const D=e[o],f=D.e||0;if(f===0)this.set(D.k,D.v);else{const E=f-s;E>0&&this.set(D.k,D.v,E)}}}prune(){this[w].forEach((e,s)=>c(this,s,!1))}}const c=(h,e,s)=>{const o=h[w].get(e);if(o){const D=o.value;if(I(h,D)){if(O(h,o),!h[L])return}else s&&(h[N]&&(o.value.now=Date.now()),h[a].unshiftNode(o));return D.value}},I=(h,e)=>{if(!e||!e.maxAge&&!h[i])return!1;const s=Date.now()-e.now;return e.maxAge?s>e.maxAge:h[i]&&s>h[i]},_=h=>{if(h[g]>h[r])for(let e=h[a].tail;h[g]>h[r]&&e!==null;){const s=e.prev;O(h,e),e=s}},O=(h,e)=>{if(e){const s=e.value;h[t]&&h[t](s.key,s.value),h[g]-=s.length,h[w].delete(s.key),h[a].removeNode(e)}};class J{constructor(e,s,o,D,f){this.key=e,this.value=s,this.length=o,this.now=D,this.maxAge=f||0}}const T=(h,e,s,o)=>{let D=s.value;I(h,D)&&(O(h,s),h[L]||(D=void 0)),D&&e.call(o,D.value,D.key,h)};return Fe=u,Fe}var He,St;function on(){if(St)return He;St=1;const x=zt(),r=10;return He=class{constructor({document:m}){this.document=m,this.cache=new x({max:r})}getProcessed(m){return this.cache.get(m)}setProcessed(m,L){this.cache.set(m,L)}},He}var Pe,Rt;function ln(){if(Rt)return Pe;Rt=1;const{isArray:x,isObject:r,isString:g}=ee(),{asArray:m}=te(),{prependBase:L}=se(),i=ne(),t=on(),n=10;Pe=class{constructor({sharedCache:j}){this.perOpCache=new Map,this.sharedCache=j}async resolve({activeCtx:j,context:u,documentLoader:c,base:I,cycles:_=new Set}){u&&r(u)&&u["@context"]&&(u=u["@context"]),u=m(u);const O=[];for(const J of u){if(g(J)){let e=this._get(J);e||(e=await this._resolveRemoteContext({activeCtx:j,url:J,documentLoader:c,base:I,cycles:_})),x(e)?O.push(...e):O.push(e);continue}if(J===null){O.push(new t({document:null}));continue}r(J)||a(u);const T=JSON.stringify(J);let h=this._get(T);h||(h=new t({document:J}),this._cacheResolvedContext({key:T,resolved:h,tag:"static"})),O.push(h)}return O}_get(j){let u=this.perOpCache.get(j);if(!u){const c=this.sharedCache.get(j);c&&(u=c.get("static"),u&&this.perOpCache.set(j,u))}return u}_cacheResolvedContext({key:j,resolved:u,tag:c}){if(this.perOpCache.set(j,u),c!==void 0){let I=this.sharedCache.get(j);I||(I=new Map,this.sharedCache.set(j,I)),I.set(c,u)}return u}async _resolveRemoteContext({activeCtx:j,url:u,documentLoader:c,base:I,cycles:_}){u=L(I,u);const{context:O,remoteDoc:J}=await this._fetchContext({activeCtx:j,url:u,documentLoader:c,cycles:_});I=J.documentUrl||u,w({context:O,base:I});const T=await this.resolve({activeCtx:j,context:O,documentLoader:c,base:I,cycles:_});return this._cacheResolvedContext({key:u,resolved:T,tag:J.tag}),T}async _fetchContext({activeCtx:j,url:u,documentLoader:c,cycles:I}){if(I.size>n)throw new i("Maximum number of @context URLs exceeded.","jsonld.ContextUrlError",{code:j.processingMode==="json-ld-1.0"?"loading remote context failed":"context overflow",max:n});if(I.has(u))throw new i("Cyclical @context URLs detected.","jsonld.ContextUrlError",{code:j.processingMode==="json-ld-1.0"?"recursive context inclusion":"context overflow",url:u});I.add(u);let _,O;try{O=await c(u),_=O.document||null,g(_)&&(_=JSON.parse(_))}catch(J){throw new i("Dereferencing a URL did not result in a valid JSON-LD object. Possible causes are an inaccessible URL perhaps due to a same-origin policy (ensure the server uses CORS if you are using client-side JavaScript), too many redirects, a non-JSON response, or more than one HTTP Link Header was provided for a remote context.","jsonld.InvalidUrl",{code:"loading remote context failed",url:u,cause:J})}if(!r(_))throw new i("Dereferencing a URL did not result in a JSON object. The response was valid JSON, but it was not a JSON object.","jsonld.InvalidUrl",{code:"invalid remote context",url:u});return"@context"in _?_={"@context":_["@context"]}:_={"@context":{}},O.contextUrl&&(x(_["@context"])||(_["@context"]=[_["@context"]]),_["@context"].push(O.contextUrl)),{context:_,remoteDoc:O}}};function a(N){throw new i("Invalid JSON-LD syntax; @context must be an object.","jsonld.SyntaxError",{code:"invalid local context",context:N})}function w({context:N,base:j}){if(!N)return;const u=N["@context"];if(g(u)){N["@context"]=L(j,u);return}if(x(u)){for(let c=0;c<u.length;++c){const I=u[c];if(g(I)){u[c]=L(j,I);continue}r(I)&&w({context:{"@context":I},base:j})}return}if(r(u))for(const c in u)w({context:u[c],base:j})}return Pe}var Be,Dt;function cn(){return Dt||(Dt=1,Be=tt().NQuads),Be}var Ue,Ot;function oe(){if(Ot)return Ue;Ot=1;const x=ne(),{isArray:r}=ee(),{asArray:g}=te(),m={};Ue=m,m.defaultEventHandler=null,m.setupEventHandler=({options:t={}})=>{const n=[].concat(t.safe?m.safeEventHandler:[],t.eventHandler?g(t.eventHandler):[],m.defaultEventHandler?m.defaultEventHandler:[]);return n.length===0?null:n},m.handleEvent=({event:t,options:n})=>{L({event:t,handlers:n.eventHandler})};function L({event:t,handlers:n}){let a=!0;for(let w=0;a&&w<n.length;++w){a=!1;const N=n[w];if(r(N))a=L({event:t,handlers:N});else if(typeof N=="function")N({event:t,next:()=>{a=!0}});else if(typeof N=="object")t.code in N?N[t.code]({event:t,next:()=>{a=!0}}):a=!0;else throw new x("Invalid event handler.","jsonld.InvalidEventHandler",{event:t})}return a}const i=new Set(["empty object","free-floating scalar","invalid @language value","invalid property","null @id value","null @value value","object with only @id","object with only @language","object with only @list","object with only @value","relative @id reference","relative @type reference","relative @vocab reference","reserved @id value","reserved @reverse value","reserved term","blank node predicate","relative graph reference","relative object reference","relative predicate reference","relative subject reference"]);return m.safeEventHandler=function({event:n,next:a}){if(n.level==="warning"&&i.has(n.code))throw new x("Safe mode validation error.","jsonld.ValidationError",{event:n});a()},m.logEventHandler=function({event:n,next:a}){console.log(`EVENT: ${n.message}`,{event:n}),a()},m.logWarningEventHandler=function({event:n,next:a}){n.level==="warning"&&console.warn(`WARNING: ${n.message}`,{event:n}),a()},m.unhandledEventHandler=function({event:n}){throw new x("No handler for event.","jsonld.UnhandledEvent",{event:n})},m.setDefaultEventHandler=function({eventHandler:t}={}){m.defaultEventHandler=t?g(t):null},Ue}var Ve,Lt;function ae(){if(Lt)return Ve;Lt=1;const x=te(),r=ne(),{isArray:g,isObject:m,isString:L,isUndefined:i}=ee(),{isAbsolute:t,isRelative:n,prependBase:a}=se(),{handleEvent:w}=oe(),{REGEX_BCP47:N,REGEX_KEYWORD:j,asArray:u,compareShortestLeast:c}=te(),I=new Map,_=1e4,O={};Ve=O,O.process=async({activeCtx:h,localCtx:e,options:s,propagate:o=!0,overrideProtected:D=!1,cycles:f=new Set})=>{if(m(e)&&"@context"in e&&g(e["@context"])&&(e=e["@context"]),u(e).length===0)return h;const b=[],F=[({event:M,next:l})=>{b.push(M),l()}];s.eventHandler&&F.push(s.eventHandler);const p=s;s={...s,eventHandler:F};const k=await s.contextResolver.resolve({activeCtx:h,context:e,documentLoader:s.documentLoader,base:s.base});m(k[0].document)&&typeof k[0].document["@propagate"]=="boolean"&&(o=k[0].document["@propagate"]);let v=h;!o&&!v.previousContext&&(v=v.clone(),v.previousContext=h);for(const M of k){let{document:l}=M;if(h=v,l===null){if(!D&&Object.keys(h.protected).length!==0)throw new r("Tried to nullify a context with protected terms outside of a term definition.","jsonld.SyntaxError",{code:"invalid context nullification"});v=h=O.getInitialContext(s).clone();continue}const R=M.getProcessed(h);if(R){if(p.eventHandler)for(const q of R.events)w({event:q,options:p});v=h=R.context;continue}if(m(l)&&"@context"in l&&(l=l["@context"]),!m(l))throw new r("Invalid JSON-LD syntax; @context must be an object.","jsonld.SyntaxError",{code:"invalid local context",context:l});v=v.clone();const H=new Map;if("@version"in l){if(l["@version"]!==1.1)throw new r("Unsupported JSON-LD version: "+l["@version"],"jsonld.UnsupportedVersion",{code:"invalid @version value",context:l});if(h.processingMode&&h.processingMode==="json-ld-1.0")throw new r("@version: "+l["@version"]+" not compatible with "+h.processingMode,"jsonld.ProcessingModeConflict",{code:"processing mode conflict",context:l});v.processingMode="json-ld-1.1",v["@version"]=l["@version"],H.set("@version",!0)}if(v.processingMode=v.processingMode||h.processingMode,"@base"in l){let q=l["@base"];if(!(q===null||t(q)))if(n(q))q=a(v["@base"],q);else throw new r('Invalid JSON-LD syntax; the value of "@base" in a @context must be an absolute IRI, a relative IRI, or null.',"jsonld.SyntaxError",{code:"invalid base IRI",context:l});v["@base"]=q,H.set("@base",!0)}if("@vocab"in l){const q=l["@vocab"];if(q===null)delete v["@vocab"];else if(L(q)){if(!t(q)&&O.processingMode(v,1))throw new r('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be an absolute IRI.',"jsonld.SyntaxError",{code:"invalid vocab mapping",context:l});{const y=J(v,q,{vocab:!0,base:!0},void 0,void 0,s);t(y)||s.eventHandler&&w({event:{type:["JsonLdEvent"],code:"relative @vocab reference",level:"warning",message:"Relative @vocab reference found.",details:{vocab:y}},options:s}),v["@vocab"]=y}}else throw new r('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be a string or null.',"jsonld.SyntaxError",{code:"invalid vocab mapping",context:l});H.set("@vocab",!0)}if("@language"in l){const q=l["@language"];if(q===null)delete v["@language"];else if(L(q))q.match(N)||s.eventHandler&&w({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:q}},options:s}),v["@language"]=q.toLowerCase();else throw new r('Invalid JSON-LD syntax; the value of "@language" in a @context must be a string or null.',"jsonld.SyntaxError",{code:"invalid default language",context:l});H.set("@language",!0)}if("@direction"in l){const q=l["@direction"];if(h.processingMode==="json-ld-1.0")throw new r("Invalid JSON-LD syntax; @direction not compatible with "+h.processingMode,"jsonld.SyntaxError",{code:"invalid context member",context:l});if(q===null)delete v["@direction"];else{if(q!=="ltr"&&q!=="rtl")throw new r('Invalid JSON-LD syntax; the value of "@direction" in a @context must be null, "ltr", or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",context:l});v["@direction"]=q}H.set("@direction",!0)}if("@propagate"in l){const q=l["@propagate"];if(h.processingMode==="json-ld-1.0")throw new r("Invalid JSON-LD syntax; @propagate not compatible with "+h.processingMode,"jsonld.SyntaxError",{code:"invalid context entry",context:l});if(typeof q!="boolean")throw new r("Invalid JSON-LD syntax; @propagate value must be a boolean.","jsonld.SyntaxError",{code:"invalid @propagate value",context:e});H.set("@propagate",!0)}if("@import"in l){const q=l["@import"];if(h.processingMode==="json-ld-1.0")throw new r("Invalid JSON-LD syntax; @import not compatible with "+h.processingMode,"jsonld.SyntaxError",{code:"invalid context entry",context:l});if(!L(q))throw new r("Invalid JSON-LD syntax; @import must be a string.","jsonld.SyntaxError",{code:"invalid @import value",context:e});const y=await s.contextResolver.resolve({activeCtx:h,context:q,documentLoader:s.documentLoader,base:s.base});if(y.length!==1)throw new r("Invalid JSON-LD syntax; @import must reference a single context.","jsonld.SyntaxError",{code:"invalid remote context",context:e});const V=y[0].getProcessed(h);if(V)l=V;else{const P=y[0].document;if("@import"in P)throw new r("Invalid JSON-LD syntax: imported context must not include @import.","jsonld.SyntaxError",{code:"invalid context entry",context:e});for(const $ in P)l.hasOwnProperty($)||(l[$]=P[$]);y[0].setProcessed(h,l)}H.set("@import",!0)}H.set("@protected",l["@protected"]||!1);for(const q in l)if(O.createTermDefinition({activeCtx:v,localCtx:l,term:q,defined:H,options:s,overrideProtected:D}),m(l[q])&&"@context"in l[q]){const y=l[q]["@context"];let V=!0;if(L(y)){const P=a(s.base,y);f.has(P)?V=!1:f.add(P)}if(V)try{await O.process({activeCtx:v.clone(),localCtx:l[q]["@context"],overrideProtected:!0,options:s,cycles:f})}catch{throw new r("Invalid JSON-LD syntax; invalid scoped context.","jsonld.SyntaxError",{code:"invalid scoped context",context:l[q]["@context"],term:q})}}M.setProcessed(h,{context:v,events:b})}return v},O.createTermDefinition=({activeCtx:h,localCtx:e,term:s,defined:o,options:D,overrideProtected:f=!1})=>{if(o.has(s)){if(o.get(s))return;throw new r("Cyclical context definition detected.","jsonld.CyclicalContext",{code:"cyclic IRI mapping",context:e,term:s})}o.set(s,!1);let E;if(e.hasOwnProperty(s)&&(E=e[s]),s==="@type"&&m(E)&&(E["@container"]||"@set")==="@set"&&O.processingMode(h,1.1)){const l=["@container","@id","@protected"],R=Object.keys(E);if(R.length===0||R.some(H=>!l.includes(H)))throw new r("Invalid JSON-LD syntax; keywords cannot be overridden.","jsonld.SyntaxError",{code:"keyword redefinition",context:e,term:s})}else{if(O.isKeyword(s))throw new r("Invalid JSON-LD syntax; keywords cannot be overridden.","jsonld.SyntaxError",{code:"keyword redefinition",context:e,term:s});if(s.match(j)){D.eventHandler&&w({event:{type:["JsonLdEvent"],code:"reserved term",level:"warning",message:'Terms beginning with "@" are reserved for future use and dropped.',details:{term:s}},options:D});return}else if(s==="")throw new r("Invalid JSON-LD syntax; a term cannot be an empty string.","jsonld.SyntaxError",{code:"invalid term definition",context:e})}const b=h.mappings.get(s);h.mappings.has(s)&&h.mappings.delete(s);let F=!1;if((L(E)||E===null)&&(F=!0,E={"@id":E}),!m(E))throw new r("Invalid JSON-LD syntax; @context term values must be strings or objects.","jsonld.SyntaxError",{code:"invalid term definition",context:e});const p={};h.mappings.set(s,p),p.reverse=!1;const k=["@container","@id","@language","@reverse","@type"];O.processingMode(h,1.1)&&k.push("@context","@direction","@index","@nest","@prefix","@protected");for(const l in E)if(!k.includes(l))throw new r("Invalid JSON-LD syntax; a term definition must not contain "+l,"jsonld.SyntaxError",{code:"invalid term definition",context:e});const v=s.indexOf(":");if(p._termHasColon=v>0,"@reverse"in E){if("@id"in E)throw new r("Invalid JSON-LD syntax; a @reverse term definition must not contain @id.","jsonld.SyntaxError",{code:"invalid reverse property",context:e});if("@nest"in E)throw new r("Invalid JSON-LD syntax; a @reverse term definition must not contain @nest.","jsonld.SyntaxError",{code:"invalid reverse property",context:e});const l=E["@reverse"];if(!L(l))throw new r("Invalid JSON-LD syntax; a @context @reverse value must be a string.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e});if(l.match(j)){D.eventHandler&&w({event:{type:["JsonLdEvent"],code:"reserved @reverse value",level:"warning",message:'@reverse values beginning with "@" are reserved for future use and dropped.',details:{reverse:l}},options:D}),b?h.mappings.set(s,b):h.mappings.delete(s);return}const R=J(h,l,{vocab:!0,base:!1},e,o,D);if(!t(R))throw new r("Invalid JSON-LD syntax; a @context @reverse value must be an absolute IRI or a blank node identifier.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e});p["@id"]=R,p.reverse=!0}else if("@id"in E){let l=E["@id"];if(l&&!L(l))throw new r("Invalid JSON-LD syntax; a @context @id value must be an array of strings or a string.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e});if(l===null)p["@id"]=null;else if(!O.isKeyword(l)&&l.match(j)){D.eventHandler&&w({event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:'@id values beginning with "@" are reserved for future use and dropped.',details:{id:l}},options:D}),b?h.mappings.set(s,b):h.mappings.delete(s);return}else if(l!==s){if(l=J(h,l,{vocab:!0,base:!1},e,o,D),!t(l)&&!O.isKeyword(l))throw new r("Invalid JSON-LD syntax; a @context @id value must be an absolute IRI, a blank node identifier, or a keyword.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e});if(s.match(/(?::[^:])|\//)){const R=new Map(o).set(s,!0);if(J(h,s,{vocab:!0,base:!1},e,R,D)!==l)throw new r("Invalid JSON-LD syntax; term in form of IRI must expand to definition.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e})}p["@id"]=l,p._prefix=F&&!p._termHasColon&&l.match(/[:\/\?#\[\]@]$/)}}if(!("@id"in p))if(p._termHasColon){const l=s.substr(0,v);if(e.hasOwnProperty(l)&&O.createTermDefinition({activeCtx:h,localCtx:e,term:l,defined:o,options:D}),h.mappings.has(l)){const R=s.substr(v+1);p["@id"]=h.mappings.get(l)["@id"]+R}else p["@id"]=s}else if(s==="@type")p["@id"]=s;else{if(!("@vocab"in h))throw new r("Invalid JSON-LD syntax; @context terms must define an @id.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e,term:s});p["@id"]=h["@vocab"]+s}if((E["@protected"]===!0||o.get("@protected")===!0&&E["@protected"]!==!1)&&(h.protected[s]=!0,p.protected=!0),o.set(s,!0),"@type"in E){let l=E["@type"];if(!L(l))throw new r("Invalid JSON-LD syntax; an @context @type value must be a string.","jsonld.SyntaxError",{code:"invalid type mapping",context:e});if(l==="@json"||l==="@none"){if(O.processingMode(h,1))throw new r(`Invalid JSON-LD syntax; an @context @type value must not be "${l}" in JSON-LD 1.0 mode.`,"jsonld.SyntaxError",{code:"invalid type mapping",context:e})}else if(l!=="@id"&&l!=="@vocab"){if(l=J(h,l,{vocab:!0,base:!1},e,o,D),!t(l))throw new r("Invalid JSON-LD syntax; an @context @type value must be an absolute IRI.","jsonld.SyntaxError",{code:"invalid type mapping",context:e});if(l.indexOf("_:")===0)throw new r("Invalid JSON-LD syntax; an @context @type value must be an IRI, not a blank node identifier.","jsonld.SyntaxError",{code:"invalid type mapping",context:e})}p["@type"]=l}if("@container"in E){const l=L(E["@container"])?[E["@container"]]:E["@container"]||[],R=["@list","@set","@index","@language"];let H=!0;const q=l.includes("@set");if(O.processingMode(h,1.1)){if(R.push("@graph","@id","@type"),l.includes("@list")){if(l.length!==1)throw new r("Invalid JSON-LD syntax; @context @container with @list must have no other values","jsonld.SyntaxError",{code:"invalid container mapping",context:e})}else if(l.includes("@graph")){if(l.some(y=>y!=="@graph"&&y!=="@id"&&y!=="@index"&&y!=="@set"))throw new r("Invalid JSON-LD syntax; @context @container with @graph must have no other values other than @id, @index, and @set","jsonld.SyntaxError",{code:"invalid container mapping",context:e})}else H&=l.length<=(q?2:1);if(l.includes("@type")&&(p["@type"]=p["@type"]||"@id",!["@id","@vocab"].includes(p["@type"])))throw new r("Invalid JSON-LD syntax; container: @type requires @type to be @id or @vocab.","jsonld.SyntaxError",{code:"invalid type mapping",context:e})}else H&=!g(E["@container"]),H&=l.length<=1;if(H&=l.every(y=>R.includes(y)),H&=!(q&&l.includes("@list")),!H)throw new r("Invalid JSON-LD syntax; @context @container value must be one of the following: "+R.join(", "),"jsonld.SyntaxError",{code:"invalid container mapping",context:e});if(p.reverse&&!l.every(y=>["@index","@set"].includes(y)))throw new r("Invalid JSON-LD syntax; @context @container value for a @reverse type definition must be @index or @set.","jsonld.SyntaxError",{code:"invalid reverse property",context:e});p["@container"]=l}if("@index"in E){if(!("@container"in E)||!p["@container"].includes("@index"))throw new r(`Invalid JSON-LD syntax; @index without @index in @container: "${E["@index"]}" on term "${s}".`,"jsonld.SyntaxError",{code:"invalid term definition",context:e});if(!L(E["@index"])||E["@index"].indexOf("@")===0)throw new r(`Invalid JSON-LD syntax; @index must expand to an IRI: "${E["@index"]}" on term "${s}".`,"jsonld.SyntaxError",{code:"invalid term definition",context:e});p["@index"]=E["@index"]}if("@context"in E&&(p["@context"]=E["@context"]),"@language"in E&&!("@type"in E)){let l=E["@language"];if(l!==null&&!L(l))throw new r("Invalid JSON-LD syntax; @context @language value must be a string or null.","jsonld.SyntaxError",{code:"invalid language mapping",context:e});l!==null&&(l=l.toLowerCase()),p["@language"]=l}if("@prefix"in E){if(s.match(/:|\//))throw new r("Invalid JSON-LD syntax; @context @prefix used on a compact IRI term","jsonld.SyntaxError",{code:"invalid term definition",context:e});if(O.isKeyword(p["@id"]))throw new r("Invalid JSON-LD syntax; keywords may not be used as prefixes","jsonld.SyntaxError",{code:"invalid term definition",context:e});if(typeof E["@prefix"]=="boolean")p._prefix=E["@prefix"]===!0;else throw new r("Invalid JSON-LD syntax; @context value for @prefix must be boolean","jsonld.SyntaxError",{code:"invalid @prefix value",context:e})}if("@direction"in E){const l=E["@direction"];if(l!==null&&l!=="ltr"&&l!=="rtl")throw new r('Invalid JSON-LD syntax; @direction value must be null, "ltr", or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",context:e});p["@direction"]=l}if("@nest"in E){const l=E["@nest"];if(!L(l)||l!=="@nest"&&l.indexOf("@")===0)throw new r("Invalid JSON-LD syntax; @context @nest value must be a string which is not a keyword other than @nest.","jsonld.SyntaxError",{code:"invalid @nest value",context:e});p["@nest"]=l}// disallow aliasing @context and @preserve
const M=p["@id"];if(M==="@context"||M==="@preserve")throw new r("Invalid JSON-LD syntax; @context and @preserve cannot be aliased.","jsonld.SyntaxError",{code:"invalid keyword alias",context:e});if(b&&b.protected&&!f&&(h.protected[s]=!0,p.protected=!0,!T(b,p)))throw new r("Invalid JSON-LD syntax; tried to redefine a protected term.","jsonld.SyntaxError",{code:"protected term redefinition",context:e,term:s})},O.expandIri=(h,e,s,o)=>J(h,e,s,void 0,void 0,o);function J(h,e,s,o,D,f){if(e===null||!L(e)||O.isKeyword(e))return e;if(e.match(j))return null;if(o&&o.hasOwnProperty(e)&&D.get(e)!==!0&&O.createTermDefinition({activeCtx:h,localCtx:o,term:e,defined:D,options:f}),s=s||{},s.vocab){const b=h.mappings.get(e);if(b===null)return null;if(m(b)&&"@id"in b)return b["@id"]}const E=e.indexOf(":");if(E>0){const b=e.substr(0,E),F=e.substr(E+1);if(b==="_"||F.indexOf("//")===0)return e;o&&o.hasOwnProperty(b)&&O.createTermDefinition({activeCtx:h,localCtx:o,term:b,defined:D,options:f});const p=h.mappings.get(b);if(p&&p._prefix)return p["@id"]+F;if(t(e))return e}if(s.vocab&&"@vocab"in h)e=h["@vocab"]+e;else if(s.base){let b,F;"@base"in h?h["@base"]?(F=a(f.base,h["@base"]),b=a(F,e)):(F=h["@base"],b=e):(F=f.base,b=a(f.base,e)),e=b}return e}O.getInitialContext=h=>{const e=JSON.stringify({processingMode:h.processingMode}),s=I.get(e);if(s)return s;const o={processingMode:h.processingMode,mappings:new Map,inverse:null,getInverse:D,clone:b,revertToPreviousContext:F,protected:{}};return I.size===_&&I.clear(),I.set(e,o),o;function D(){const p=this;if(p.inverse)return p.inverse;const k=p.inverse={},v=p.fastCurieMap={},M={},l=(p["@language"]||"@none").toLowerCase(),R=p["@direction"],H=p.mappings,q=[...H.keys()].sort(c);for(const y of q){const V=H.get(y);if(V===null)continue;let P=V["@container"]||"@none";if(P=[].concat(P).sort().join(""),V["@id"]===null)continue;const $=u(V["@id"]);for(const B of $){let S=k[B];const d=O.isKeyword(B);if(S)!d&&!V._termHasColon&&M[B].push(y);else if(k[B]=S={},!d&&!V._termHasColon){M[B]=[y];const A={iri:B,terms:M[B]};B[0]in v?v[B[0]].push(A):v[B[0]]=[A]}if(S[P]||(S[P]={"@language":{},"@type":{},"@any":{}}),S=S[P],E(y,S["@any"],"@none"),V.reverse)E(y,S["@type"],"@reverse");else if(V["@type"]==="@none")E(y,S["@any"],"@none"),E(y,S["@language"],"@none"),E(y,S["@type"],"@none");else if("@type"in V)E(y,S["@type"],V["@type"]);else if("@language"in V&&"@direction"in V){const A=V["@language"],U=V["@direction"];A&&U?E(y,S["@language"],`${A}_${U}`.toLowerCase()):A?E(y,S["@language"],A.toLowerCase()):U?E(y,S["@language"],`_${U}`):E(y,S["@language"],"@null")}else"@language"in V?E(y,S["@language"],(V["@language"]||"@null").toLowerCase()):"@direction"in V?V["@direction"]?E(y,S["@language"],`_${V["@direction"]}`):E(y,S["@language"],"@none"):R?(E(y,S["@language"],`_${R}`),E(y,S["@language"],"@none"),E(y,S["@type"],"@none")):(E(y,S["@language"],l),E(y,S["@language"],"@none"),E(y,S["@type"],"@none"))}}for(const y in v)f(v,y,1);return k}function f(p,k,v){const M=p[k],l=p[k]={};let R,H;for(const q of M)R=q.iri,v>=R.length?H="":H=R[v],H in l?l[H].push(q):l[H]=[q];for(const q in l)q!==""&&f(l,q,v+1)}function E(p,k,v){k.hasOwnProperty(v)||(k[v]=p)}function b(){const p={};return p.mappings=x.clone(this.mappings),p.clone=this.clone,p.inverse=null,p.getInverse=this.getInverse,p.protected=x.clone(this.protected),this.previousContext&&(p.previousContext=this.previousContext.clone()),p.revertToPreviousContext=this.revertToPreviousContext,"@base"in this&&(p["@base"]=this["@base"]),"@language"in this&&(p["@language"]=this["@language"]),"@vocab"in this&&(p["@vocab"]=this["@vocab"]),p}function F(){return this.previousContext?this.previousContext.clone():this}},O.getContextValue=(h,e,s)=>{if(e===null)return s==="@context"?void 0:null;if(h.mappings.has(e)){const o=h.mappings.get(e);if(i(s))return o;if(o.hasOwnProperty(s))return o[s]}if(s==="@language"&&s in h||s==="@direction"&&s in h)return h[s];if(s!=="@context")return null},O.processingMode=(h,e)=>e.toString()>="1.1"?!h.processingMode||h.processingMode>="json-ld-"+e.toString():h.processingMode==="json-ld-1.0",O.isKeyword=h=>{if(!L(h)||h[0]!=="@")return!1;switch(h){case"@base":case"@container":case"@context":case"@default":case"@direction":case"@embed":case"@explicit":case"@graph":case"@id":case"@included":case"@index":case"@json":case"@language":case"@list":case"@nest":case"@none":case"@omitDefault":case"@prefix":case"@preserve":case"@protected":case"@requireAll":case"@reverse":case"@set":case"@type":case"@value":case"@version":case"@vocab":return!0}return!1};function T(h,e){if(!(h&&typeof h=="object")||!(e&&typeof e=="object"))return h===e;const s=Array.isArray(h);if(s!==Array.isArray(e))return!1;if(s){if(h.length!==e.length)return!1;for(let f=0;f<h.length;++f)if(!T(h[f],e[f]))return!1;return!0}const o=Object.keys(h),D=Object.keys(e);if(o.length!==D.length)return!1;for(const f in h){let E=h[f],b=e[f];if(f==="@container"&&Array.isArray(E)&&Array.isArray(b)&&(E=E.slice().sort(),b=b.slice().sort()),!T(E,b))return!1}return!0}return Ve}var Ge,At;function un(){if(At)return Ge;At=1;const x=ne(),{isArray:r,isObject:g,isEmptyObject:m,isString:L,isUndefined:i}=ee(),{isList:t,isValue:n,isGraph:a,isSubject:w}=re(),{expandIri:N,getContextValue:j,isKeyword:u,process:c,processingMode:I}=ae(),{isAbsolute:_}=se(),{REGEX_BCP47:O,REGEX_KEYWORD:J,addValue:T,asArray:h,getValues:e,validateTypeValue:s}=te(),{handleEvent:o}=oe(),D={};Ge=D,D.expand=async({activeCtx:p,activeProperty:k=null,element:v,options:M={},insideList:l=!1,insideIndex:R=!1,typeScopedContext:H=null})=>{if(v==null)return null;if(k==="@default"&&(M=Object.assign({},M,{isFrame:!1})),!r(v)&&!g(v))return!l&&(k===null||N(p,k,{vocab:!0},M)==="@graph")?(M.eventHandler&&o({event:{type:["JsonLdEvent"],code:"free-floating scalar",level:"warning",message:"Dropping free-floating scalar not in a list.",details:{value:v}},options:M}),null):E({activeCtx:p,activeProperty:k,value:v,options:M});if(r(v)){let d=[];const A=j(p,k,"@container")||[];l=l||A.includes("@list");for(let U=0;U<v.length;++U){let Q=await D.expand({activeCtx:p,activeProperty:k,element:v[U],options:M,insideIndex:R,typeScopedContext:H});l&&r(Q)&&(Q={"@list":Q}),Q!==null&&(r(Q)?d=d.concat(Q):d.push(Q))}return d}const q=N(p,k,{vocab:!0},M),y=j(p,k,"@context");H=H||(p.previousContext?p:null);let V=Object.keys(v).sort(),P=!R;if(P&&H&&V.length<=2&&!V.includes("@context"))for(const d of V){const A=N(H,d,{vocab:!0},M);if(A==="@value"){P=!1,p=H;break}if(A==="@id"&&V.length===1){P=!1;break}}P&&(p=p.revertToPreviousContext()),i(y)||(p=await c({activeCtx:p,localCtx:y,propagate:!0,overrideProtected:!0,options:M})),"@context"in v&&(p=await c({activeCtx:p,localCtx:v["@context"],options:M})),H=p;let $=null;for(const d of V)if(N(p,d,{vocab:!0},M)==="@type"){$=$||d;const U=v[d],Q=Array.isArray(U)?U.length>1?U.slice().sort():U:[U];for(const z of Q){const K=j(H,z,"@context");i(K)||(p=await c({activeCtx:p,localCtx:K,options:M,propagate:!1}))}}let B={};await f({activeCtx:p,activeProperty:k,expandedActiveProperty:q,element:v,expandedParent:B,options:M,insideList:l,typeKey:$,typeScopedContext:H}),V=Object.keys(B);let S=V.length;if("@value"in B){if("@type"in B&&("@language"in B||"@direction"in B))throw new x('Invalid JSON-LD syntax; an element containing "@value" may not contain both "@type" and either "@language" or "@direction".',"jsonld.SyntaxError",{code:"invalid value object",element:B});let d=S-1;if("@type"in B&&(d-=1),"@index"in B&&(d-=1),"@language"in B&&(d-=1),"@direction"in B&&(d-=1),d!==0)throw new x('Invalid JSON-LD syntax; an element containing "@value" may only have an "@index" property and either "@type" or either or both "@language" or "@direction".',"jsonld.SyntaxError",{code:"invalid value object",element:B});const A=B["@value"]===null?[]:h(B["@value"]),U=e(B,"@type");if(!(I(p,1.1)&&U.includes("@json")&&U.length===1))if(A.length===0)M.eventHandler&&o({event:{type:["JsonLdEvent"],code:"null @value value",level:"warning",message:"Dropping null @value value.",details:{value:B}},options:M}),B=null;else{if(!A.every(Q=>L(Q)||m(Q))&&"@language"in B)throw new x("Invalid JSON-LD syntax; only strings may be language-tagged.","jsonld.SyntaxError",{code:"invalid language-tagged value",element:B});if(!U.every(Q=>_(Q)&&!(L(Q)&&Q.indexOf("_:")===0)||m(Q)))throw new x('Invalid JSON-LD syntax; an element containing "@value" and "@type" must have an absolute IRI for the value of "@type".',"jsonld.SyntaxError",{code:"invalid typed value",element:B})}}else if("@type"in B&&!r(B["@type"]))B["@type"]=[B["@type"]];else if("@set"in B||"@list"in B){if(S>1&&!(S===2&&"@index"in B))throw new x('Invalid JSON-LD syntax; if an element has the property "@set" or "@list", then it can have at most one other property that is "@index".',"jsonld.SyntaxError",{code:"invalid set or list object",element:B});"@set"in B&&(B=B["@set"],V=Object.keys(B),S=V.length)}else S===1&&"@language"in B&&(M.eventHandler&&o({event:{type:["JsonLdEvent"],code:"object with only @language",level:"warning",message:"Dropping object with only @language.",details:{value:B}},options:M}),B=null);if(g(B)&&!M.keepFreeFloatingNodes&&!l&&(k===null||q==="@graph")&&(S===0||"@value"in B||"@list"in B||S===1&&"@id"in B)){if(M.eventHandler){let d,A;S===0?(d="empty object",A="Dropping empty object."):"@value"in B?(d="object with only @value",A="Dropping object with only @value."):"@list"in B?(d="object with only @list",A="Dropping object with only @list."):S===1&&"@id"in B&&(d="object with only @id",A="Dropping object with only @id."),o({event:{type:["JsonLdEvent"],code:d,level:"warning",message:A,details:{value:B}},options:M})}B=null}return B};async function f({activeCtx:p,activeProperty:k,expandedActiveProperty:v,element:M,expandedParent:l,options:R={},insideList:H,typeKey:q,typeScopedContext:y}){const V=Object.keys(M).sort(),P=[];let $;const B=M[q]&&N(p,r(M[q])?M[q][0]:M[q],{vocab:!0},{...R,typeExpansion:!0})==="@json";for(const S of V){let d=M[S],A;if(S==="@context")continue;const U=N(p,S,{vocab:!0},R);if(U===null||!(_(U)||u(U))){R.eventHandler&&o({event:{type:["JsonLdEvent"],code:"invalid property",level:"warning",message:"Dropping property that did not expand into an absolute IRI or keyword.",details:{property:S,expandedProperty:U}},options:R});continue}if(u(U)){if(v==="@reverse")throw new x("Invalid JSON-LD syntax; a keyword cannot be used as a @reverse property.","jsonld.SyntaxError",{code:"invalid reverse property map",value:d});if(U in l&&U!=="@included"&&U!=="@type")throw new x("Invalid JSON-LD syntax; colliding keywords detected.","jsonld.SyntaxError",{code:"colliding keywords",keyword:U})}if(U==="@id"){if(!L(d)){if(!R.isFrame)throw new x('Invalid JSON-LD syntax; "@id" value must a string.',"jsonld.SyntaxError",{code:"invalid @id value",value:d});if(g(d)){if(!m(d))throw new x('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:d})}else if(r(d)){if(!d.every(G=>L(G)))throw new x('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:d})}else throw new x('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:d})}T(l,"@id",h(d).map(G=>{if(L(G)){const X=N(p,G,{base:!0},R);return R.eventHandler&&(X===null?o(G===null?{event:{type:["JsonLdEvent"],code:"null @id value",level:"warning",message:"Null @id found.",details:{id:G}},options:R}:{event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:"Reserved @id found.",details:{id:G}},options:R}):_(X)||o({event:{type:["JsonLdEvent"],code:"relative @id reference",level:"warning",message:"Relative @id reference found.",details:{id:G,expandedId:X}},options:R})),X}return G}),{propertyIsArray:R.isFrame});continue}if(U==="@type"){g(d)&&(d=Object.fromEntries(Object.entries(d).map(([G,X])=>[N(y,G,{vocab:!0}),h(X).map(W=>N(y,W,{base:!0,vocab:!0},{...R,typeExpansion:!0}))]))),s(d,R.isFrame),T(l,"@type",h(d).map(G=>{if(L(G)){const X=N(y,G,{base:!0,vocab:!0},{...R,typeExpansion:!0});return X!=="@json"&&!_(X)&&R.eventHandler&&o({event:{type:["JsonLdEvent"],code:"relative @type reference",level:"warning",message:"Relative @type reference found.",details:{type:G}},options:R}),X}return G}),{propertyIsArray:R.isFrame});continue}if(U==="@included"&&I(p,1.1)){const G=h(await D.expand({activeCtx:p,activeProperty:k,element:d,options:R}));if(!G.every(X=>w(X)))throw new x("Invalid JSON-LD syntax; values of @included must expand to node objects.","jsonld.SyntaxError",{code:"invalid @included value",value:d});T(l,"@included",G,{propertyIsArray:!0});continue}if(U==="@graph"&&!(g(d)||r(d)))throw new x('Invalid JSON-LD syntax; "@graph" value must not be an object or an array.',"jsonld.SyntaxError",{code:"invalid @graph value",value:d});if(U==="@value"){$=d,B&&I(p,1.1)?l["@value"]=d:T(l,"@value",d,{propertyIsArray:R.isFrame});continue}if(U==="@language"){if(d===null)continue;if(!L(d)&&!R.isFrame)throw new x('Invalid JSON-LD syntax; "@language" value must be a string.',"jsonld.SyntaxError",{code:"invalid language-tagged string",value:d});d=h(d).map(G=>L(G)?G.toLowerCase():G);for(const G of d)L(G)&&!G.match(O)&&R.eventHandler&&o({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:G}},options:R});T(l,"@language",d,{propertyIsArray:R.isFrame});continue}if(U==="@direction"){if(!L(d)&&!R.isFrame)throw new x('Invalid JSON-LD syntax; "@direction" value must be a string.',"jsonld.SyntaxError",{code:"invalid base direction",value:d});d=h(d);for(const G of d)if(L(G)&&G!=="ltr"&&G!=="rtl")throw new x('Invalid JSON-LD syntax; "@direction" must be "ltr" or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",value:d});T(l,"@direction",d,{propertyIsArray:R.isFrame});continue}if(U==="@index"){if(!L(d))throw new x('Invalid JSON-LD syntax; "@index" value must be a string.',"jsonld.SyntaxError",{code:"invalid @index value",value:d});T(l,"@index",d);continue}if(U==="@reverse"){if(!g(d))throw new x('Invalid JSON-LD syntax; "@reverse" value must be an object.',"jsonld.SyntaxError",{code:"invalid @reverse value",value:d});if(A=await D.expand({activeCtx:p,activeProperty:"@reverse",element:d,options:R}),"@reverse"in A)for(const X in A["@reverse"])T(l,X,A["@reverse"][X],{propertyIsArray:!0});let G=l["@reverse"]||null;for(const X in A){if(X==="@reverse")continue;G===null&&(G=l["@reverse"]={}),T(G,X,[],{propertyIsArray:!0});const W=A[X];for(let Z=0;Z<W.length;++Z){const C=W[Z];if(n(C)||t(C))throw new x('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',"jsonld.SyntaxError",{code:"invalid reverse property value",value:A});T(G,X,C,{propertyIsArray:!0})}}continue}if(U==="@nest"){P.push(S);continue}let Q=p;const z=j(p,S,"@context");i(z)||(Q=await c({activeCtx:p,localCtx:z,propagate:!0,overrideProtected:!0,options:R}));const K=j(Q,S,"@container")||[];if(K.includes("@language")&&g(d)){const G=j(Q,S,"@direction");A=b(Q,d,G,R)}else if(K.includes("@index")&&g(d)){const G=K.includes("@graph"),X=j(Q,S,"@index")||"@index",W=X!=="@index"&&N(p,X,{vocab:!0},R);A=await F({activeCtx:Q,options:R,activeProperty:S,value:d,asGraph:G,indexKey:X,propertyIndex:W})}else if(K.includes("@id")&&g(d)){const G=K.includes("@graph");A=await F({activeCtx:Q,options:R,activeProperty:S,value:d,asGraph:G,indexKey:"@id"})}else if(K.includes("@type")&&g(d))A=await F({activeCtx:Q.revertToPreviousContext(),options:R,activeProperty:S,value:d,asGraph:!1,indexKey:"@type"});else{const G=U==="@list";if(G||U==="@set"){let X=k;G&&v==="@graph"&&(X=null),A=await D.expand({activeCtx:Q,activeProperty:X,element:d,options:R,insideList:G})}else j(p,S,"@type")==="@json"?A={"@type":"@json","@value":d}:A=await D.expand({activeCtx:Q,activeProperty:S,element:d,options:R,insideList:!1})}if(!(A===null&&U!=="@value")){if(U!=="@list"&&!t(A)&&K.includes("@list")&&(A={"@list":h(A)}),K.includes("@graph")&&!K.some(G=>G==="@id"||G==="@index")&&(A=h(A).map(G=>({"@graph":h(G)}))),Q.mappings.has(S)&&Q.mappings.get(S).reverse){const G=l["@reverse"]=l["@reverse"]||{};A=h(A);for(let X=0;X<A.length;++X){const W=A[X];if(n(W)||t(W))throw new x('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',"jsonld.SyntaxError",{code:"invalid reverse property value",value:A});T(G,U,W,{propertyIsArray:!0})}continue}T(l,U,A,{propertyIsArray:!0})}}if("@value"in l&&!(l["@type"]==="@json"&&I(p,1.1))){if((g($)||r($))&&!R.isFrame)throw new x('Invalid JSON-LD syntax; "@value" value must not be an object or an array.',"jsonld.SyntaxError",{code:"invalid value object value",value:$})}for(const S of P){const d=r(M[S])?M[S]:[M[S]];for(const A of d){if(!g(A)||Object.keys(A).some(U=>N(p,U,{vocab:!0},R)==="@value"))throw new x("Invalid JSON-LD syntax; nested value must be a node object.","jsonld.SyntaxError",{code:"invalid @nest value",value:A});await f({activeCtx:p,activeProperty:k,expandedActiveProperty:v,element:A,expandedParent:l,options:R,insideList:H,typeScopedContext:y,typeKey:q})}}}function E({activeCtx:p,activeProperty:k,value:v,options:M}){if(v==null)return null;const l=N(p,k,{vocab:!0},M);if(l==="@id")return N(p,v,{base:!0},M);if(l==="@type")return N(p,v,{vocab:!0,base:!0},{...M,typeExpansion:!0});const R=j(p,k,"@type");if((R==="@id"||l==="@graph")&&L(v)){const q=N(p,v,{base:!0},M);return q===null&&v.match(J)&&M.eventHandler&&o({event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:"Reserved @id found.",details:{id:k}},options:M}),{"@id":q}}if(R==="@vocab"&&L(v))return{"@id":N(p,v,{vocab:!0,base:!0},M)};if(u(l))return v;const H={};if(R&&!["@id","@vocab","@none"].includes(R))H["@type"]=R;else if(L(v)){const q=j(p,k,"@language");q!==null&&(H["@language"]=q);const y=j(p,k,"@direction");y!==null&&(H["@direction"]=y)}return["boolean","number","string"].includes(typeof v)||(v=v.toString()),H["@value"]=v,H}function b(p,k,v,M){const l=[],R=Object.keys(k).sort();for(const H of R){const q=N(p,H,{vocab:!0},M);let y=k[H];r(y)||(y=[y]);for(const V of y){if(V===null)continue;if(!L(V))throw new x("Invalid JSON-LD syntax; language map values must be strings.","jsonld.SyntaxError",{code:"invalid language map value",languageMap:k});const P={"@value":V};q!=="@none"&&(H.match(O)||M.eventHandler&&o({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:H}},options:M}),P["@language"]=H.toLowerCase()),v&&(P["@direction"]=v),l.push(P)}}return l}async function F({activeCtx:p,options:k,activeProperty:v,value:M,asGraph:l,indexKey:R,propertyIndex:H}){const q=[],y=Object.keys(M).sort(),V=R==="@type";for(let P of y){if(V){const S=j(p,P,"@context");i(S)||(p=await c({activeCtx:p,localCtx:S,propagate:!1,options:k}))}let $=M[P];r($)||($=[$]),$=await D.expand({activeCtx:p,activeProperty:v,element:$,options:k,insideList:!1,insideIndex:!0});let B;H?P==="@none"?B="@none":B=E({activeCtx:p,activeProperty:R,value:P,options:k}):B=N(p,P,{vocab:!0},k),R==="@id"?P=N(p,P,{base:!0},k):V&&(P=B);for(let S of $){if(l&&!a(S)&&(S={"@graph":[S]}),R==="@type")B==="@none"||(S["@type"]?S["@type"]=[P].concat(S["@type"]):S["@type"]=[P]);else{if(n(S)&&!["@language","@type","@index"].includes(R))throw new x(`Invalid JSON-LD syntax; Attempt to add illegal key to value object: "${R}".`,"jsonld.SyntaxError",{code:"invalid value object",value:S});H?B!=="@none"&&T(S,H,B,{propertyIsArray:!0,prependValue:!0}):B!=="@none"&&!(R in S)&&(S[R]=P)}q.push(S)}}return q}return Ge}var $e,Tt;function he(){if(Tt)return $e;Tt=1;const{isKeyword:x}=ae(),r=re(),g=ee(),m=te(),L=ne(),i={};return $e=i,i.createMergedNodeMap=(t,n)=>{n=n||{};const a=n.issuer||new m.IdentifierIssuer("_:b"),w={"@default":{}};return i.createNodeMap(t,w,"@default",a),i.mergeNodeMaps(w)},i.createNodeMap=(t,n,a,w,N,j)=>{if(g.isArray(t)){for(const _ of t)i.createNodeMap(_,n,a,w,void 0,j);return}if(!g.isObject(t)){j&&j.push(t);return}if(r.isValue(t)){if("@type"in t){let _=t["@type"];_.indexOf("_:")===0&&(t["@type"]=_=w.getId(_))}j&&j.push(t);return}else if(j&&r.isList(t)){const _=[];i.createNodeMap(t["@list"],n,a,w,N,_),j.push({"@list":_});return}if("@type"in t){const _=t["@type"];for(const O of _)O.indexOf("_:")===0&&w.getId(O)}g.isUndefined(N)&&(N=r.isBlankNode(t)?w.getId(t["@id"]):t["@id"]),j&&j.push({"@id":N});const u=n[a],c=u[N]=u[N]||{};c["@id"]=N;const I=Object.keys(t).sort();for(let _ of I){if(_==="@id")continue;if(_==="@reverse"){const J={"@id":N},T=t["@reverse"];for(const h in T){const e=T[h];for(const s of e){let o=s["@id"];r.isBlankNode(s)&&(o=w.getId(o)),i.createNodeMap(s,n,a,w,o),m.addValue(u[o],h,J,{propertyIsArray:!0,allowDuplicate:!1})}}continue}if(_==="@graph"){N in n||(n[N]={}),i.createNodeMap(t[_],n,N,w);continue}if(_==="@included"){i.createNodeMap(t[_],n,a,w);continue}if(_!=="@type"&&x(_)){if(_==="@index"&&_ in c&&(t[_]!==c[_]||t[_]["@id"]!==c[_]["@id"]))throw new L("Invalid JSON-LD syntax; conflicting @index property detected.","jsonld.SyntaxError",{code:"conflicting indexes",subject:c});c[_]=t[_];continue}const O=t[_];if(_.indexOf("_:")===0&&(_=w.getId(_)),O.length===0){m.addValue(c,_,[],{propertyIsArray:!0});continue}for(let J of O)if(_==="@type"&&(J=J.indexOf("_:")===0?w.getId(J):J),r.isSubject(J)||r.isSubjectReference(J)){if("@id"in J&&!J["@id"])continue;const T=r.isBlankNode(J)?w.getId(J["@id"]):J["@id"];m.addValue(c,_,{"@id":T},{propertyIsArray:!0,allowDuplicate:!1}),i.createNodeMap(J,n,a,w,T)}else if(r.isValue(J))m.addValue(c,_,J,{propertyIsArray:!0,allowDuplicate:!1});else if(r.isList(J)){const T=[];i.createNodeMap(J["@list"],n,a,w,N,T),J={"@list":T},m.addValue(c,_,J,{propertyIsArray:!0,allowDuplicate:!1})}else i.createNodeMap(J,n,a,w,N),m.addValue(c,_,J,{propertyIsArray:!0,allowDuplicate:!1})}},i.mergeNodeMapGraphs=t=>{const n={};for(const a of Object.keys(t).sort())for(const w of Object.keys(t[a]).sort()){const N=t[a][w];w in n||(n[w]={"@id":w});const j=n[w];for(const u of Object.keys(N).sort())if(x(u)&&u!=="@type")j[u]=m.clone(N[u]);else for(const c of N[u])m.addValue(j,u,m.clone(c),{propertyIsArray:!0,allowDuplicate:!1})}return n},i.mergeNodeMaps=t=>{const n=t["@default"],a=Object.keys(t).sort();for(const w of a){if(w==="@default")continue;const N=t[w];let j=n[w];j?"@graph"in j||(j["@graph"]=[]):n[w]=j={"@id":w,"@graph":[]};const u=j["@graph"];for(const c of Object.keys(N).sort()){const I=N[c];r.isSubjectReference(I)||u.push(I)}}return n},$e}var ze,kt;function dn(){if(kt)return ze;kt=1;const{isSubjectReference:x}=re(),{createMergedNodeMap:r}=he(),g={};return ze=g,g.flatten=m=>{const L=r(m),i=[],t=Object.keys(L).sort();for(let n=0;n<t.length;++n){const a=L[t[n]];x(a)||i.push(a)}return i},ze}var Qe,Mt;function fn(){if(Mt)return Qe;Mt=1;const x=ne(),r=re(),g=ee(),{REGEX_BCP47:m,addValue:L}=te(),{handleEvent:i}=oe(),{RDF_LIST:t,RDF_FIRST:n,RDF_REST:a,RDF_NIL:w,RDF_TYPE:N,RDF_JSON_LITERAL:j,XSD_BOOLEAN:u,XSD_DOUBLE:c,XSD_INTEGER:I,XSD_STRING:_}=nt(),O={};Qe=O,O.fromRDF=async(T,h)=>{const e={},s={"@default":e},o={},{useRdfType:D=!1,useNativeTypes:f=!1,rdfDirection:E=null}=h;for(const p of T){const k=p.graph.termType==="DefaultGraph"?"@default":p.graph.value;k in s||(s[k]={}),k!=="@default"&&!(k in e)&&(e[k]={"@id":k});const v=s[k],M=p.subject.value,l=p.predicate.value,R=p.object;M in v||(v[M]={"@id":M});const H=v[M],q=R.termType.endsWith("Node");if(q&&!(R.value in v)&&(v[R.value]={"@id":R.value}),l===N&&!D&&q){L(H,"@type",R.value,{propertyIsArray:!0});continue}const y=J(R,f,E,h);if(L(H,l,y,{propertyIsArray:!0}),q)if(R.value===w){const V=v[R.value];"usages"in V||(V.usages=[]),V.usages.push({node:H,property:l,value:y})}else R.value in o?o[R.value]=!1:o[R.value]={node:H,property:l,value:y}}for(const p in s){const k=s[p];if(!(w in k))continue;const v=k[w];if(v.usages){for(let M of v.usages){let l=M.node,R=M.property,H=M.value;const q=[],y=[];let V=Object.keys(l).length;for(;R===a&&g.isObject(o[l["@id"]])&&g.isArray(l[n])&&l[n].length===1&&g.isArray(l[a])&&l[a].length===1&&(V===3||V===4&&g.isArray(l["@type"])&&l["@type"].length===1&&l["@type"][0]===t)&&(q.push(l[n][0]),y.push(l["@id"]),M=o[l["@id"]],l=M.node,R=M.property,H=M.value,V=Object.keys(l).length,!!r.isBlankNode(l)););delete H["@id"],H["@list"]=q.reverse();for(const P of y)delete k[P]}delete v.usages}}const b=[],F=Object.keys(e).sort();for(const p of F){const k=e[p];if(p in s){const v=k["@graph"]=[],M=s[p],l=Object.keys(M).sort();for(const R of l){const H=M[R];r.isSubjectReference(H)||v.push(H)}}r.isSubjectReference(k)||b.push(k)}return b};function J(T,h,e,s){if(T.termType.endsWith("Node"))return{"@id":T.value};const o={"@value":T.value};if(T.language)T.language.match(m)||s.eventHandler&&i({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:T.language}},options:s}),o["@language"]=T.language;else{let D=T.datatype.value;if(D||(D=_),D===j){D="@json";try{o["@value"]=JSON.parse(o["@value"])}catch(f){throw new x("JSON literal could not be parsed.","jsonld.InvalidJsonLiteral",{code:"invalid JSON literal",value:o["@value"],cause:f})}}if(h){if(D===u)o["@value"]==="true"?o["@value"]=!0:o["@value"]==="false"&&(o["@value"]=!1);else if(g.isNumeric(o["@value"]))if(D===I){const f=parseInt(o["@value"],10);f.toFixed(0)===o["@value"]&&(o["@value"]=f)}else D===c&&(o["@value"]=parseFloat(o["@value"]));[u,I,c,_].includes(D)||(o["@type"]=D)}else if(e==="i18n-datatype"&&D.startsWith("https://www.w3.org/ns/i18n#")){const[,f,E]=D.split(/[#_]/);f.length>0&&(o["@language"]=f,f.match(m)||s.eventHandler&&i({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:f}},options:s})),o["@direction"]=E}else D!==_&&(o["@type"]=D)}return o}return Qe}var Xe,qt;function hn(){if(qt)return Xe;qt=1;const{createNodeMap:x}=he(),{isKeyword:r}=ae(),g=re(),m=Ct(),L=ee(),i=te(),{handleEvent:t}=oe(),{RDF_FIRST:n,RDF_REST:a,RDF_NIL:w,RDF_TYPE:N,RDF_JSON_LITERAL:j,RDF_LANGSTRING:u,XSD_BOOLEAN:c,XSD_DOUBLE:I,XSD_INTEGER:_,XSD_STRING:O}=nt(),{isAbsolute:J}=se(),T={};Xe=T,T.toRDF=(o,D)=>{const f=new i.IdentifierIssuer("_:b"),E={"@default":{}};x(o,E,"@default",f);const b=[],F=Object.keys(E).sort();for(const p of F){let k;if(p==="@default")k={termType:"DefaultGraph",value:""};else if(J(p))p.startsWith("_:")?k={termType:"BlankNode"}:k={termType:"NamedNode"},k.value=p;else{D.eventHandler&&t({event:{type:["JsonLdEvent"],code:"relative graph reference",level:"warning",message:"Relative graph reference found.",details:{graph:p}},options:D});continue}h(b,E[p],k,f,D)}return b};function h(o,D,f,E,b){const F=Object.keys(D).sort();for(const p of F){const k=D[p],v=Object.keys(k).sort();for(let M of v){const l=k[M];if(M==="@type")M=N;else if(r(M))continue;for(const R of l){const H={termType:p.startsWith("_:")?"BlankNode":"NamedNode",value:p};if(!J(p)){b.eventHandler&&t({event:{type:["JsonLdEvent"],code:"relative subject reference",level:"warning",message:"Relative subject reference found.",details:{subject:p}},options:b});continue}const q={termType:M.startsWith("_:")?"BlankNode":"NamedNode",value:M};if(!J(M)){b.eventHandler&&t({event:{type:["JsonLdEvent"],code:"relative predicate reference",level:"warning",message:"Relative predicate reference found.",details:{predicate:M}},options:b});continue}if(q.termType==="BlankNode"&&!b.produceGeneralizedRdf){b.eventHandler&&t({event:{type:["JsonLdEvent"],code:"blank node predicate",level:"warning",message:"Dropping blank node predicate.",details:{property:E.getOldIds().find(V=>E.getId(V)===M)}},options:b});continue}const y=s(R,E,o,f,b.rdfDirection,b);y&&o.push({subject:H,predicate:q,object:y,graph:f})}}}}function e(o,D,f,E,b,F){const p={termType:"NamedNode",value:n},k={termType:"NamedNode",value:a},v={termType:"NamedNode",value:w},M=o.pop(),l=M?{termType:"BlankNode",value:D.getId()}:v;let R=l;for(const H of o){const q=s(H,D,f,E,b,F),y={termType:"BlankNode",value:D.getId()};f.push({subject:R,predicate:p,object:q,graph:E}),f.push({subject:R,predicate:k,object:y,graph:E}),R=y}if(M){const H=s(M,D,f,E,b,F);f.push({subject:R,predicate:p,object:H,graph:E}),f.push({subject:R,predicate:k,object:v,graph:E})}return l}function s(o,D,f,E,b,F){const p={};if(g.isValue(o)){p.termType="Literal",p.value=void 0,p.datatype={termType:"NamedNode"};let k=o["@value"];const v=o["@type"]||null;if(v==="@json")p.value=m(k),p.datatype.value=j;else if(L.isBoolean(k))p.value=k.toString(),p.datatype.value=v||c;else if(L.isDouble(k)||v===I)L.isDouble(k)||(k=parseFloat(k)),p.value=k.toExponential(15).replace(/(\d)0*e\+?/,"$1E"),p.datatype.value=v||I;else if(L.isNumber(k))p.value=k.toFixed(0),p.datatype.value=v||_;else if(b==="i18n-datatype"&&"@direction"in o){const M="https://www.w3.org/ns/i18n#"+(o["@language"]||"")+`_${o["@direction"]}`;p.datatype.value=M,p.value=k}else"@language"in o?(p.value=k,p.datatype.value=v||u,p.language=o["@language"]):(p.value=k,p.datatype.value=v||O)}else if(g.isList(o)){const k=e(o["@list"],D,f,E,b,F);p.termType=k.termType,p.value=k.value}else{const k=L.isObject(o)?o["@id"]:o;p.termType=k.startsWith("_:")?"BlankNode":"NamedNode",p.value=k}return p.termType==="NamedNode"&&!J(p.value)?(F.eventHandler&&t({event:{type:["JsonLdEvent"],code:"relative object reference",level:"warning",message:"Relative object reference found.",details:{object:p.value}},options:F}),null):p}return Xe}var Ke,Jt;function pn(){if(Jt)return Ke;Jt=1;const{isKeyword:x}=ae(),r=re(),g=ee(),m=te(),L=se(),i=ne(),{createNodeMap:t,mergeNodeMapGraphs:n}=he(),a={};Ke=a,a.frameMergedOrDefault=(e,s,o)=>{const D={options:o,embedded:!1,graph:"@default",graphMap:{"@default":{}},subjectStack:[],link:{},bnodeMap:{}},f=new m.IdentifierIssuer("_:b");t(e,D.graphMap,"@default",f),o.merged&&(D.graphMap["@merged"]=n(D.graphMap),D.graph="@merged"),D.subjects=D.graphMap[D.graph];const E=[];a.frame(D,Object.keys(D.subjects).sort(),s,E),o.pruneBlankNodeIdentifiers&&(o.bnodesToClear=Object.keys(D.bnodeMap).filter(b=>D.bnodeMap[b].length===1));// remove @preserve from results
return o.link={},O(E,o)},a.frame=(e,s,o,D,f=null)=>{u(o),o=o[0];const E=e.options,b={embed:j(o,E,"embed"),explicit:j(o,E,"explicit"),requireAll:j(o,E,"requireAll")};e.link.hasOwnProperty(e.graph)||(e.link[e.graph]={});const F=e.link[e.graph],p=c(e,s,o,b),k=Object.keys(p).sort();for(const v of k){const M=p[v];if(f===null?e.uniqueEmbeds={[e.graph]:{}}:e.uniqueEmbeds[e.graph]=e.uniqueEmbeds[e.graph]||{},b.embed==="@link"&&v in F){J(D,f,F[v]);continue}const l={"@id":v};if(v.indexOf("_:")===0&&m.addValue(e.bnodeMap,v,l,{propertyIsArray:!0}),F[v]=l,(b.embed==="@first"||b.embed==="@last")&&e.is11)throw new i("Invalid JSON-LD syntax; invalid value of @embed.","jsonld.SyntaxError",{code:"invalid @embed value",frame:o});if(!(!e.embedded&&e.uniqueEmbeds[e.graph].hasOwnProperty(v))){if(e.embedded&&(b.embed==="@never"||N(M,e.graph,e.subjectStack))){J(D,f,l);continue}if(e.embedded&&(b.embed=="@first"||b.embed=="@once")&&e.uniqueEmbeds[e.graph].hasOwnProperty(v)){J(D,f,l);continue}if(b.embed==="@last"&&v in e.uniqueEmbeds[e.graph]&&_(e,v),e.uniqueEmbeds[e.graph][v]={parent:D,property:f},e.subjectStack.push({subject:M,graph:e.graph}),v in e.graphMap){let R=!1,H=null;"@graph"in o?(H=o["@graph"][0],R=!(v==="@merged"||v==="@default"),g.isObject(H)||(H={})):(R=e.graph!=="@merged",H={}),R&&a.frame({...e,graph:v,embedded:!1},Object.keys(e.graphMap[v]).sort(),[H],l,"@graph")}"@included"in o&&a.frame({...e,embedded:!1},s,o["@included"],l,"@included");for(const R of Object.keys(M).sort()){if(x(R)){if(l[R]=m.clone(M[R]),R==="@type")for(const H of M["@type"])H.indexOf("_:")===0&&m.addValue(e.bnodeMap,H,l,{propertyIsArray:!0});continue}if(!(b.explicit&&!(R in o)))for(const H of M[R]){const q=R in o?o[R]:w(b);if(r.isList(H)){const y=o[R]&&o[R][0]&&o[R][0]["@list"]?o[R][0]["@list"]:w(b),V={"@list":[]};J(l,R,V);const P=H["@list"];for(const $ of P)r.isSubjectReference($)?a.frame({...e,embedded:!0},[$["@id"]],y,V,"@list"):J(V,"@list",m.clone($))}else r.isSubjectReference(H)?a.frame({...e,embedded:!0},[H["@id"]],q,l,R):h(q[0],H)&&J(l,R,m.clone(H))}}for(const R of Object.keys(o).sort()){if(R==="@type"){if(!g.isObject(o[R][0])||!("@default"in o[R][0]))continue}else if(x(R))continue;const H=o[R][0]||{};if(!j(H,E,"omitDefault")&&!(R in l)){let y="@null";"@default"in H&&(y=m.clone(H["@default"])),g.isArray(y)||(y=[y]),l[R]=[{"@preserve":y}]}}for(const R of Object.keys(o["@reverse"]||{}).sort()){const H=o["@reverse"][R];for(const q of Object.keys(e.subjects))m.getValues(e.subjects[q],R).some(V=>V["@id"]===v)&&(l["@reverse"]=l["@reverse"]||{},m.addValue(l["@reverse"],R,[],{propertyIsArray:!0}),a.frame({...e,embedded:!0},[q],H,l["@reverse"][R],f))}J(D,f,l),e.subjectStack.pop()}}},a.cleanupNull=(e,s)=>{if(g.isArray(e))return e.map(D=>a.cleanupNull(D,s)).filter(D=>D);if(e==="@null")return null;if(g.isObject(e)){if("@id"in e){const o=e["@id"];if(s.link.hasOwnProperty(o)){const D=s.link[o].indexOf(e);if(D!==-1)return s.link[o][D];s.link[o].push(e)}else s.link[o]=[e]}for(const o in e)e[o]=a.cleanupNull(e[o],s)}return e};function w(e){const s={};for(const o in e)e[o]!==void 0&&(s["@"+o]=[e[o]]);return[s]}function N(e,s,o){for(let D=o.length-1;D>=0;--D){const f=o[D];if(f.graph===s&&f.subject["@id"]===e["@id"])return!0}return!1}function j(e,s,o){const D="@"+o;let f=D in e?e[D][0]:s[o];if(o==="embed"){if(f===!0)f="@once";else if(f===!1)f="@never";else if(f!=="@always"&&f!=="@never"&&f!=="@link"&&f!=="@first"&&f!=="@last"&&f!=="@once")throw new i("Invalid JSON-LD syntax; invalid value of @embed.","jsonld.SyntaxError",{code:"invalid @embed value",frame:e})}return f}function u(e){if(!g.isArray(e)||e.length!==1||!g.isObject(e[0]))throw new i("Invalid JSON-LD syntax; a JSON-LD frame must be a single object.","jsonld.SyntaxError",{frame:e});if("@id"in e[0]){for(const s of m.asArray(e[0]["@id"]))if(!(g.isObject(s)||L.isAbsolute(s))||g.isString(s)&&s.indexOf("_:")===0)throw new i("Invalid JSON-LD syntax; invalid @id in frame.","jsonld.SyntaxError",{code:"invalid frame",frame:e})}if("@type"in e[0]){for(const s of m.asArray(e[0]["@type"]))if(!(g.isObject(s)||L.isAbsolute(s))||g.isString(s)&&s.indexOf("_:")===0)throw new i("Invalid JSON-LD syntax; invalid @type in frame.","jsonld.SyntaxError",{code:"invalid frame",frame:e})}}function c(e,s,o,D){const f={};for(const E of s){const b=e.graphMap[e.graph][E];I(e,b,o,D)&&(f[E]=b)}return f}function I(e,s,o,D){let f=!0,E=!1;for(const b in o){let F=!1;const p=m.getValues(s,b),k=m.getValues(o,b).length===0;if(b==="@id"){if(g.isEmptyObject(o["@id"][0]||{})?F=!0:o["@id"].length>=0&&(F=o["@id"].includes(p[0])),!D.requireAll)return F}else if(b==="@type"){if(f=!1,k){if(p.length>0)return!1;F=!0}else if(o["@type"].length===1&&g.isEmptyObject(o["@type"][0]))F=p.length>0;else for(const v of o["@type"])g.isObject(v)&&"@default"in v?F=!0:F=F||p.some(M=>M===v);if(!D.requireAll)return F}else{if(x(b))continue;{const v=m.getValues(o,b)[0];let M=!1;if(v&&(u([v]),M="@default"in v),f=!1,p.length===0&&M)continue;if(p.length>0&&k)return!1;if(v===void 0){if(p.length>0)return!1;F=!0}else if(r.isList(v)){const l=v["@list"][0];if(r.isList(p[0])){const R=p[0]["@list"];r.isValue(l)?F=R.some(H=>h(l,H)):(r.isSubject(l)||r.isSubjectReference(l))&&(F=R.some(H=>T(e,l,H,D)))}}else r.isValue(v)?F=p.some(l=>h(v,l)):r.isSubjectReference(v)?F=p.some(l=>T(e,v,l,D)):g.isObject(v)?F=p.length>0:F=!1}}if(!F&&D.requireAll)return!1;E=E||F}return f||E}function _(e,s){const o=e.uniqueEmbeds[e.graph],D=o[s],f=D.parent,E=D.property,b={"@id":s};if(g.isArray(f)){for(let p=0;p<f.length;++p)if(m.compareValues(f[p],b)){f[p]=b;break}}else{const p=g.isArray(f[E]);m.removeValue(f,E,b,{propertyIsArray:p}),m.addValue(f,E,b,{propertyIsArray:p})}const F=p=>{const k=Object.keys(o);for(const v of k)v in o&&g.isObject(o[v].parent)&&o[v].parent["@id"]===p&&(delete o[v],F(v))};F(s)}/**
 * Removes the @preserve keywords from expanded result of framing.
 *
 * @param input the framed, framed output.
 * @param options the framing options used.
 *
 * @return the resulting output.
 */function O(e,s){if(g.isArray(e))return e.map(o=>O(o,s));if(g.isObject(e)){// remove @preserve
if("@preserve"in e)return e["@preserve"][0];if(r.isValue(e))return e;if(r.isList(e))return e["@list"]=O(e["@list"],s),e;if("@id"in e){const o=e["@id"];if(s.link.hasOwnProperty(o)){const D=s.link[o].indexOf(e);if(D!==-1)return s.link[o][D];s.link[o].push(e)}else s.link[o]=[e]}for(const o in e){if(o==="@id"&&s.bnodesToClear.includes(e[o])){delete e["@id"];continue}e[o]=O(e[o],s)}}return e}function J(e,s,o){g.isObject(e)?m.addValue(e,s,o,{propertyIsArray:!0}):e.push(o)}function T(e,s,o,D){if(!("@id"in o))return!1;const f=e.subjects[o["@id"]];return f&&I(e,f,s,D)}function h(e,s){const o=s["@value"],D=s["@type"],f=s["@language"],E=e["@value"]?g.isArray(e["@value"])?e["@value"]:[e["@value"]]:[],b=e["@type"]?g.isArray(e["@type"])?e["@type"]:[e["@type"]]:[],F=e["@language"]?g.isArray(e["@language"])?e["@language"]:[e["@language"]]:[];return E.length===0&&b.length===0&&F.length===0?!0:!(!(E.includes(o)||g.isEmptyObject(E[0]))||!(!D&&b.length===0||b.includes(D)||D&&g.isEmptyObject(b[0]))||!(!f&&F.length===0||F.includes(f)||f&&g.isEmptyObject(F[0])))}return Ke}var We,Ft;function gn(){if(Ft)return We;Ft=1;const x=ne(),{isArray:r,isObject:g,isString:m,isUndefined:L}=ee(),{isList:i,isValue:t,isGraph:n,isSimpleGraph:a,isSubjectReference:w}=re(),{expandIri:N,getContextValue:j,isKeyword:u,process:c,processingMode:I}=ae(),{removeBase:_,prependBase:O}=se(),{REGEX_KEYWORD:J,addValue:T,asArray:h,compareShortestLeast:e}=te(),s={};We=s,s.compact=async({activeCtx:f,activeProperty:E=null,element:b,options:F={}})=>{if(r(b)){let k=[];for(let v=0;v<b.length;++v){const M=await s.compact({activeCtx:f,activeProperty:E,element:b[v],options:F});M!==null&&k.push(M)}return F.compactArrays&&k.length===1&&(j(f,E,"@container")||[]).length===0&&(k=k[0]),k}const p=j(f,E,"@context");if(L(p)||(f=await c({activeCtx:f,localCtx:p,propagate:!0,overrideProtected:!0,options:F})),g(b)){if(F.link&&"@id"in b&&F.link.hasOwnProperty(b["@id"])){const y=F.link[b["@id"]];for(let V=0;V<y.length;++V)if(y[V].expanded===b)return y[V].compacted}if(t(b)||w(b)){const y=s.compactValue({activeCtx:f,activeProperty:E,value:b,options:F});return F.link&&w(b)&&(F.link.hasOwnProperty(b["@id"])||(F.link[b["@id"]]=[]),F.link[b["@id"]].push({expanded:b,compacted:y})),y}if(i(b)&&(j(f,E,"@container")||[]).includes("@list"))return s.compact({activeCtx:f,activeProperty:E,element:b["@list"],options:F});const k=E==="@reverse",v={},M=f;!t(b)&&!w(b)&&(f=f.revertToPreviousContext());const l=j(M,E,"@context");L(l)||(f=await c({activeCtx:f,localCtx:l,propagate:!0,overrideProtected:!0,options:F})),F.link&&"@id"in b&&(F.link.hasOwnProperty(b["@id"])||(F.link[b["@id"]]=[]),F.link[b["@id"]].push({expanded:b,compacted:v}));let R=b["@type"]||[];R.length>1&&(R=Array.from(R).sort());const H=f;for(const y of R){const V=s.compactIri({activeCtx:H,iri:y,relativeTo:{vocab:!0}}),P=j(M,V,"@context");L(P)||(f=await c({activeCtx:f,localCtx:P,options:F,propagate:!1}))}const q=Object.keys(b).sort();for(const y of q){const V=b[y];if(y==="@id"){let P=h(V).map(B=>s.compactIri({activeCtx:f,iri:B,relativeTo:{vocab:!1},base:F.base}));P.length===1&&(P=P[0]);const $=s.compactIri({activeCtx:f,iri:"@id",relativeTo:{vocab:!0}});v[$]=P;continue}if(y==="@type"){let P=h(V).map(A=>s.compactIri({activeCtx:M,iri:A,relativeTo:{vocab:!0}}));P.length===1&&(P=P[0]);const $=s.compactIri({activeCtx:f,iri:"@type",relativeTo:{vocab:!0}}),d=(j(f,$,"@container")||[]).includes("@set")&&I(f,1.1)||r(P)&&V.length===0;T(v,$,P,{propertyIsArray:d});continue}if(y==="@reverse"){const P=await s.compact({activeCtx:f,activeProperty:"@reverse",element:V,options:F});for(const $ in P)if(f.mappings.has($)&&f.mappings.get($).reverse){const B=P[$],d=(j(f,$,"@container")||[]).includes("@set")||!F.compactArrays;T(v,$,B,{propertyIsArray:d}),delete P[$]}if(Object.keys(P).length>0){const $=s.compactIri({activeCtx:f,iri:y,relativeTo:{vocab:!0}});T(v,$,P)}continue}if(y==="@preserve"){const P=await s.compact({activeCtx:f,activeProperty:E,element:V,options:F});r(P)&&P.length===0||T(v,y,P);continue}if(y==="@index"){if((j(f,E,"@container")||[]).includes("@index"))continue;const $=s.compactIri({activeCtx:f,iri:y,relativeTo:{vocab:!0}});T(v,$,V);continue}if(y!=="@graph"&&y!=="@list"&&y!=="@included"&&u(y)){const P=s.compactIri({activeCtx:f,iri:y,relativeTo:{vocab:!0}});T(v,P,V);continue}if(!r(V))throw new x("JSON-LD expansion error; expanded value must be an array.","jsonld.SyntaxError");if(V.length===0){const P=s.compactIri({activeCtx:f,iri:y,value:V,relativeTo:{vocab:!0},reverse:k}),$=f.mappings.has(P)?f.mappings.get(P)["@nest"]:null;let B=v;$&&(D(f,$,F),g(v[$])||(v[$]={}),B=v[$]),T(B,P,V,{propertyIsArray:!0})}for(const P of V){const $=s.compactIri({activeCtx:f,iri:y,value:P,relativeTo:{vocab:!0},reverse:k}),B=f.mappings.has($)?f.mappings.get($)["@nest"]:null;let S=v;B&&(D(f,B,F),g(v[B])||(v[B]={}),S=v[B]);const d=j(f,$,"@container")||[],A=n(P),U=i(P);let Q;U?Q=P["@list"]:A&&(Q=P["@graph"]);let z=await s.compact({activeCtx:f,activeProperty:$,element:U||A?Q:P,options:F});if(U)if(r(z)||(z=[z]),!d.includes("@list"))z={[s.compactIri({activeCtx:f,iri:"@list",relativeTo:{vocab:!0}})]:z},"@index"in P&&(z[s.compactIri({activeCtx:f,iri:"@index",relativeTo:{vocab:!0}})]=P["@index"]);else{T(S,$,z,{valueIsArray:!0,allowDuplicate:!0});continue}if(A)if(d.includes("@graph")&&(d.includes("@id")||d.includes("@index")&&a(P))){let K;S.hasOwnProperty($)?K=S[$]:S[$]=K={};const G=(d.includes("@id")?P["@id"]:P["@index"])||s.compactIri({activeCtx:f,iri:"@none",relativeTo:{vocab:!0}});T(K,G,z,{propertyIsArray:!F.compactArrays||d.includes("@set")})}else d.includes("@graph")&&a(P)?(r(z)&&z.length>1&&(z={"@included":z}),T(S,$,z,{propertyIsArray:!F.compactArrays||d.includes("@set")})):(r(z)&&z.length===1&&F.compactArrays&&(z=z[0]),z={[s.compactIri({activeCtx:f,iri:"@graph",relativeTo:{vocab:!0}})]:z},"@id"in P&&(z[s.compactIri({activeCtx:f,iri:"@id",relativeTo:{vocab:!0}})]=P["@id"]),"@index"in P&&(z[s.compactIri({activeCtx:f,iri:"@index",relativeTo:{vocab:!0}})]=P["@index"]),T(S,$,z,{propertyIsArray:!F.compactArrays||d.includes("@set")}));else if(d.includes("@language")||d.includes("@index")||d.includes("@id")||d.includes("@type")){let K;S.hasOwnProperty($)?K=S[$]:S[$]=K={};let G;if(d.includes("@language"))t(z)&&(z=z["@value"]),G=P["@language"];else if(d.includes("@index")){const X=j(f,$,"@index")||"@index",W=s.compactIri({activeCtx:f,iri:X,relativeTo:{vocab:!0}});if(X==="@index")G=P["@index"],delete z[W];else{let Z;if([G,...Z]=h(z[X]||[]),!m(G))G=null;else switch(Z.length){case 0:delete z[X];break;case 1:z[X]=Z[0];break;default:z[X]=Z;break}}}else if(d.includes("@id")){const X=s.compactIri({activeCtx:f,iri:"@id",relativeTo:{vocab:!0}});G=z[X],delete z[X]}else if(d.includes("@type")){const X=s.compactIri({activeCtx:f,iri:"@type",relativeTo:{vocab:!0}});let W;switch([G,...W]=h(z[X]||[]),W.length){case 0:delete z[X];break;case 1:z[X]=W[0];break;default:z[X]=W;break}Object.keys(z).length===1&&"@id"in P&&(z=await s.compact({activeCtx:f,activeProperty:$,element:{"@id":P["@id"]},options:F}))}G||(G=s.compactIri({activeCtx:f,iri:"@none",relativeTo:{vocab:!0}})),T(K,G,z,{propertyIsArray:d.includes("@set")})}else{const K=!F.compactArrays||d.includes("@set")||d.includes("@list")||r(z)&&z.length===0||y==="@list"||y==="@graph";T(S,$,z,{propertyIsArray:K})}}}return v}return b},s.compactIri=({activeCtx:f,iri:E,value:b=null,relativeTo:F={vocab:!1},reverse:p=!1,base:k=null})=>{if(E===null)return E;f.isPropertyTermScoped&&f.previousContext&&(f=f.previousContext);const v=f.getInverse();if(u(E)&&E in v&&"@none"in v[E]&&"@type"in v[E]["@none"]&&"@none"in v[E]["@none"]["@type"])return v[E]["@none"]["@type"]["@none"];if(F.vocab&&E in v){const q=f["@language"]||"@none",y=[];g(b)&&"@index"in b&&!("@graph"in b)&&y.push("@index","@index@set"),g(b)&&"@preserve"in b&&(b=b["@preserve"][0]),n(b)?("@index"in b&&y.push("@graph@index","@graph@index@set","@index","@index@set"),"@id"in b&&y.push("@graph@id","@graph@id@set"),y.push("@graph","@graph@set","@set"),"@index"in b||y.push("@graph@index","@graph@index@set","@index","@index@set"),"@id"in b||y.push("@graph@id","@graph@id@set")):g(b)&&!t(b)&&y.push("@id","@id@set","@type","@set@type");let V="@language",P="@null";if(p)V="@type",P="@reverse",y.push("@set");else if(i(b)){"@index"in b||y.push("@list");const B=b["@list"];if(B.length===0)V="@any",P="@none";else{let S=B.length===0?q:null,d=null;for(let A=0;A<B.length;++A){const U=B[A];let Q="@none",z="@none";if(t(U))if("@direction"in U){const K=(U["@language"]||"").toLowerCase(),G=U["@direction"];Q=`${K}_${G}`}else"@language"in U?Q=U["@language"].toLowerCase():"@type"in U?z=U["@type"]:Q="@null";else z="@id";if(S===null?S=Q:Q!==S&&t(U)&&(S="@none"),d===null?d=z:z!==d&&(d="@none"),S==="@none"&&d==="@none")break}S=S||"@none",d=d||"@none",d!=="@none"?(V="@type",P=d):P=S}}else{if(t(b))if("@language"in b&&!("@index"in b)){y.push("@language","@language@set"),P=b["@language"];const B=b["@direction"];B&&(P=`${P}_${B}`)}else"@direction"in b&&!("@index"in b)?P=`_${b["@direction"]}`:"@type"in b&&(V="@type",P=b["@type"]);else V="@type",P="@id";y.push("@set")}y.push("@none"),g(b)&&!("@index"in b)&&y.push("@index","@index@set"),t(b)&&Object.keys(b).length===1&&y.push("@language","@language@set");const $=o(f,E,b,y,V,P);if($!==null)return $}if(F.vocab&&"@vocab"in f){const q=f["@vocab"];if(E.indexOf(q)===0&&E!==q){const y=E.substr(q.length);if(!f.mappings.has(y))return y}}let M=null;const l=[];let R=f.fastCurieMap;const H=E.length-1;for(let q=0;q<H&&E[q]in R;++q)R=R[E[q]],""in R&&l.push(R[""][0]);for(let q=l.length-1;q>=0;--q){const y=l[q],V=y.terms;for(const P of V){const $=P+":"+E.substr(y.iri.length);f.mappings.get(P)._prefix&&(!f.mappings.has($)||b===null&&f.mappings.get($)["@id"]===E)&&(M===null||e($,M)<0)&&(M=$)}}if(M!==null)return M;for(const[q,y]of f.mappings)if(y&&y._prefix&&E.startsWith(q+":"))throw new x(`Absolute IRI "${E}" confused with prefix "${q}".`,"jsonld.SyntaxError",{code:"IRI confused with prefix",context:f});if(!F.vocab)if("@base"in f)if(f["@base"]){const q=_(O(k,f["@base"]),E);return J.test(q)?`./${q}`:q}else return E;else return _(k,E);return E},s.compactValue=({activeCtx:f,activeProperty:E,value:b,options:F})=>{if(t(b)){const M=j(f,E,"@type"),l=j(f,E,"@language"),R=j(f,E,"@direction"),H=j(f,E,"@container")||[],q="@index"in b&&!H.includes("@index");if(!q&&M!=="@none"&&(b["@type"]===M||"@language"in b&&b["@language"]===l&&"@direction"in b&&b["@direction"]===R||"@language"in b&&b["@language"]===l||"@direction"in b&&b["@direction"]===R))return b["@value"];const y=Object.keys(b).length,V=y===1||y===2&&"@index"in b&&!q,P="@language"in f,$=m(b["@value"]),B=f.mappings.has(E)&&f.mappings.get(E)["@language"]===null;if(V&&M!=="@none"&&(!P||!$||B))return b["@value"];const S={};return q&&(S[s.compactIri({activeCtx:f,iri:"@index",relativeTo:{vocab:!0}})]=b["@index"]),"@type"in b?S[s.compactIri({activeCtx:f,iri:"@type",relativeTo:{vocab:!0}})]=s.compactIri({activeCtx:f,iri:b["@type"],relativeTo:{vocab:!0}}):"@language"in b&&(S[s.compactIri({activeCtx:f,iri:"@language",relativeTo:{vocab:!0}})]=b["@language"]),"@direction"in b&&(S[s.compactIri({activeCtx:f,iri:"@direction",relativeTo:{vocab:!0}})]=b["@direction"]),S[s.compactIri({activeCtx:f,iri:"@value",relativeTo:{vocab:!0}})]=b["@value"],S}const p=N(f,E,{vocab:!0},F),k=j(f,E,"@type"),v=s.compactIri({activeCtx:f,iri:b["@id"],relativeTo:{vocab:k==="@vocab"},base:F.base});return k==="@id"||k==="@vocab"||p==="@graph"?v:{[s.compactIri({activeCtx:f,iri:"@id",relativeTo:{vocab:!0}})]:v}};function o(f,E,b,F,p,k){k===null&&(k="@null");const v=[];if((k==="@id"||k==="@reverse")&&g(b)&&"@id"in b){k==="@reverse"&&v.push("@reverse");const l=s.compactIri({activeCtx:f,iri:b["@id"],relativeTo:{vocab:!0}});f.mappings.has(l)&&f.mappings.get(l)&&f.mappings.get(l)["@id"]===b["@id"]?v.push.apply(v,["@vocab","@id"]):v.push.apply(v,["@id","@vocab"])}else{v.push(k);const l=v.find(R=>R.includes("_"));l&&v.push(l.replace(/^[^_]+_/,"_"))}v.push("@none");const M=f.inverse[E];for(const l of F){if(!(l in M))continue;const R=M[l][p];for(const H of v)if(H in R)return R[H]}return null}function D(f,E,b){if(N(f,E,{vocab:!0},b)!=="@nest")throw new x("JSON-LD compact error; nested property must have an @nest value resolving to @nest.","jsonld.SyntaxError",{code:"invalid @nest value"})}return We}var Ce,Ht;function yn(){return Ht||(Ht=1,Ce=x=>{class r{toString(){return"[object JsonLdProcessor]"}}return Object.defineProperty(r,"prototype",{writable:!1,enumerable:!1}),Object.defineProperty(r.prototype,"constructor",{writable:!0,enumerable:!1,configurable:!0,value:r}),r.compact=function(g,m){return arguments.length<2?Promise.reject(new TypeError("Could not compact, too few arguments.")):x.compact(g,m)},r.expand=function(g){return arguments.length<1?Promise.reject(new TypeError("Could not expand, too few arguments.")):x.expand(g)},r.flatten=function(g){return arguments.length<1?Promise.reject(new TypeError("Could not flatten, too few arguments.")):x.flatten(g)},r}),Ce}/**
 * A JavaScript implementation of the JSON-LD API.
 *
 * @author Dave Longley
 *
 * @license BSD 3-Clause License
 * Copyright (c) 2011-2022 Digital Bazaar, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the Digital Bazaar, Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */var Ye,Pt;function mn(){if(Pt)return Ye;Pt=1;const x=tt(),r=rn(),g=te(),m=ln(),L=g.IdentifierIssuer,i=ne(),t=zt(),n=cn(),{expand:a}=un(),{flatten:w}=dn(),{fromRDF:N}=fn(),{toRDF:j}=hn(),{frameMergedOrDefault:u,cleanupNull:c}=pn(),{isArray:I,isObject:_,isString:O}=ee(),{isSubjectReference:J}=re(),{expandIri:T,getInitialContext:h,process:e,processingMode:s}=ae(),{compact:o,compactIri:D}=gn(),{createNodeMap:f,createMergedNodeMap:E,mergeNodeMaps:b}=he(),{logEventHandler:F,logWarningEventHandler:p,safeEventHandler:k,setDefaultEventHandler:v,setupEventHandler:M,strictEventHandler:l,unhandledEventHandler:R}=oe(),H=function(y){const V={},$=new t({max:100});y.compact=async function(S,d,A){if(arguments.length<2)throw new TypeError("Could not compact, too few arguments.");if(d===null)throw new i("The compaction context must not be null.","jsonld.CompactError",{code:"invalid local context"});if(S===null)return null;A=B(A,{base:O(S)?S:"",compactArrays:!0,compactToRelative:!0,graph:!1,skipExpansion:!1,link:!1,issuer:new L("_:b"),contextResolver:new m({sharedCache:$})}),A.link&&(A.skipExpansion=!0),A.compactToRelative||delete A.base;let U;A.skipExpansion?U=S:U=await y.expand(S,A);const Q=await y.processContext(h(A),d,A);let z=await o({activeCtx:Q,element:U,options:A});A.compactArrays&&!A.graph&&I(z)?z.length===1?z=z[0]:z.length===0&&(z={}):A.graph&&_(z)&&(z=[z]),_(d)&&"@context"in d&&(d=d["@context"]),d=g.clone(d),I(d)||(d=[d]);const K=d;d=[];for(let X=0;X<K.length;++X)(!_(K[X])||Object.keys(K[X]).length>0)&&d.push(K[X]);const G=d.length>0;if(d.length===1&&(d=d[0]),I(z)){const X=D({activeCtx:Q,iri:"@graph",relativeTo:{vocab:!0}}),W=z;z={},G&&(z["@context"]=d),z[X]=W}else if(_(z)&&G){const X=z;z={"@context":d};for(const W in X)z[W]=X[W]}return z},y.expand=async function(S,d){if(arguments.length<1)throw new TypeError("Could not expand, too few arguments.");d=B(d,{keepFreeFloatingNodes:!1,contextResolver:new m({sharedCache:$})});const A={},U=[];if("expandContext"in d){const G=g.clone(d.expandContext);_(G)&&"@context"in G?A.expandContext=G:A.expandContext={"@context":G},U.push(A.expandContext)}let Q;if(!O(S))A.input=g.clone(S);else{const G=await y.get(S,d);Q=G.documentUrl,A.input=G.document,G.contextUrl&&(A.remoteContext={"@context":G.contextUrl},U.push(A.remoteContext))}"base"in d||(d.base=Q||"");let z=h(d);for(const G of U)z=await e({activeCtx:z,localCtx:G,options:d});let K=await a({activeCtx:z,element:A.input,options:d});return _(K)&&"@graph"in K&&Object.keys(K).length===1?K=K["@graph"]:K===null&&(K=[]),I(K)||(K=[K]),K},y.flatten=async function(S,d,A){if(arguments.length<1)return new TypeError("Could not flatten, too few arguments.");typeof d=="function"?d=null:d=d||null,A=B(A,{base:O(S)?S:"",contextResolver:new m({sharedCache:$})});const U=await y.expand(S,A),Q=w(U);return d===null?Q:(A.graph=!0,A.skipExpansion=!0,await y.compact(Q,d,A))},y.frame=async function(S,d,A){if(arguments.length<2)throw new TypeError("Could not frame, too few arguments.");if(A=B(A,{base:O(S)?S:"",embed:"@once",explicit:!1,requireAll:!1,omitDefault:!1,bnodesToClear:[],contextResolver:new m({sharedCache:$})}),O(d)){const C=await y.get(d,A);if(d=C.document,C.contextUrl){let Y=d["@context"];Y?I(Y)?Y.push(C.contextUrl):Y=[Y,C.contextUrl]:Y=C.contextUrl,d["@context"]=Y}}const U=d?d["@context"]||{}:{},Q=await y.processContext(h(A),U,A);A.hasOwnProperty("omitGraph")||(A.omitGraph=s(Q,1.1)),A.hasOwnProperty("pruneBlankNodeIdentifiers")||(A.pruneBlankNodeIdentifiers=s(Q,1.1));const z=await y.expand(S,A),K={...A};K.isFrame=!0,K.keepFreeFloatingNodes=!0;const G=await y.expand(d,K),X=Object.keys(d).map(C=>T(Q,C,{vocab:!0}));K.merged=!X.includes("@graph"),K.is11=s(Q,1.1);const W=u(z,G,K);K.graph=!A.omitGraph,K.skipExpansion=!0,K.link={},K.framing=!0;let Z=await y.compact(W,U,K);return K.link={},Z=c(Z,K),Z},y.link=async function(S,d,A){const U={};return d&&(U["@context"]=d),U["@embed"]="@link",y.frame(S,U,A)},y.normalize=y.canonize=async function(S,d){if(arguments.length<1)throw new TypeError("Could not canonize, too few arguments.");if(d=B(d,{base:O(S)?S:null,algorithm:"URDNA2015",skipExpansion:!1,safe:!0,contextResolver:new m({sharedCache:$})}),"inputFormat"in d){if(d.inputFormat!=="application/n-quads"&&d.inputFormat!=="application/nquads")throw new i("Unknown canonicalization input format.","jsonld.CanonizeError");const Q=n.parse(S);return x.canonize(Q,d)}const A={...d};delete A.format,A.produceGeneralizedRdf=!1;const U=await y.toRDF(S,A);return x.canonize(U,d)},y.fromRDF=async function(S,d){if(arguments.length<1)throw new TypeError("Could not convert from RDF, too few arguments.");d=B(d,{format:O(S)?"application/n-quads":void 0});const{format:A}=d;let{rdfParser:U}=d;if(A){if(U=U||V[A],!U)throw new i("Unknown input format.","jsonld.UnknownFormat",{format:A})}else U=()=>S;const Q=await U(S);return N(Q,d)},y.toRDF=async function(S,d){if(arguments.length<1)throw new TypeError("Could not convert to RDF, too few arguments.");d=B(d,{base:O(S)?S:"",skipExpansion:!1,contextResolver:new m({sharedCache:$})});let A;d.skipExpansion?A=S:A=await y.expand(S,d);const U=j(A,d);if(d.format){if(d.format==="application/n-quads"||d.format==="application/nquads")return n.serialize(U);throw new i("Unknown output format.","jsonld.UnknownFormat",{format:d.format})}return U},y.createNodeMap=async function(S,d){if(arguments.length<1)throw new TypeError("Could not create node map, too few arguments.");d=B(d,{base:O(S)?S:"",contextResolver:new m({sharedCache:$})});const A=await y.expand(S,d);return E(A,d)},y.merge=async function(S,d,A){if(arguments.length<1)throw new TypeError("Could not merge, too few arguments.");if(!I(S))throw new TypeError('Could not merge, "docs" must be an array.');typeof d=="function"?d=null:d=d||null,A=B(A,{contextResolver:new m({sharedCache:$})});const U=await Promise.all(S.map(C=>{const Y={...A};return y.expand(C,Y)}));let Q=!0;"mergeNodes"in A&&(Q=A.mergeNodes);const z=A.issuer||new L("_:b"),K={"@default":{}};for(let C=0;C<U.length;++C){const Y=g.relabelBlankNodes(U[C],{issuer:new L("_:b"+C+"-")}),le=Q||C===0?K:{"@default":{}};if(f(Y,le,"@default",z),le!==K)for(const ce in le){const pe=le[ce];if(!(ce in K)){K[ce]=pe;continue}const rt=K[ce];for(const ge in pe)ge in rt||(rt[ge]=pe[ge])}}const G=b(K),X=[],W=Object.keys(G).sort();for(let C=0;C<W.length;++C){const Y=G[W[C]];J(Y)||X.push(Y)}return d===null?X:(A.graph=!0,A.skipExpansion=!0,await y.compact(X,d,A))},Object.defineProperty(y,"documentLoader",{get:()=>y._documentLoader,set:S=>y._documentLoader=S}),y.documentLoader=async S=>{throw new i("Could not retrieve a JSON-LD document from the URL. URL dereferencing not implemented.","jsonld.LoadDocumentError",{code:"loading document failed",url:S})},y.get=async function(S,d){let A;typeof d.documentLoader=="function"?A=d.documentLoader:A=y.documentLoader;const U=await A(S);try{if(!U.document)throw new i("No remote document found at the given URL.","jsonld.NullRemoteDocument");O(U.document)&&(U.document=JSON.parse(U.document))}catch(Q){throw new i("Could not retrieve a JSON-LD document from the URL.","jsonld.LoadDocumentError",{code:"loading document failed",cause:Q,remoteDoc:U})}return U},y.processContext=async function(S,d,A){return A=B(A,{base:"",contextResolver:new m({sharedCache:$})}),d===null?h(A):(d=g.clone(d),_(d)&&"@context"in d||(d={"@context":d}),e({activeCtx:S,localCtx:d,options:A}))},y.getContextValue=ae().getContextValue,y.documentLoaders={},y.useDocumentLoader=function(S){if(!(S in y.documentLoaders))throw new i('Unknown document loader type: "'+S+'"',"jsonld.UnknownDocumentLoader",{type:S});y.documentLoader=y.documentLoaders[S].apply(y,Array.prototype.slice.call(arguments,1))},y.registerRDFParser=function(S,d){V[S]=d},y.unregisterRDFParser=function(S){delete V[S]},y.registerRDFParser("application/n-quads",n.parse),y.registerRDFParser("application/nquads",n.parse),y.url=se(),y.logEventHandler=F,y.logWarningEventHandler=p,y.safeEventHandler=k,y.setDefaultEventHandler=v,y.strictEventHandler=l,y.unhandledEventHandler=R,y.util=g,Object.assign(y,g),y.promises=y,y.RequestQueue=$t(),y.JsonLdProcessor=yn()(y),r.setupGlobals(y),r.setupDocumentLoaders(y);function B(S,{documentLoader:d=y.documentLoader,...A}){if(S&&"compactionMap"in S)throw new i('"compactionMap" not supported.',"jsonld.OptionsError");if(S&&"expansionMap"in S)throw new i('"expansionMap" not supported.',"jsonld.OptionsError");return Object.assign({},{documentLoader:d},A,S,{eventHandler:M({options:S})})}return y},q=function(){return H(function(){return q()})};return H(q),Ye=q,Ye}var vn=mn();const ue=Kt(vn);async function bn(x){const r=[];for await(const g of x)r.push(g);return r}class ie extends Wt.Readable{constructor(r,{baseIRI:g,compact:m,context:L={},encoding:i="object",flatten:t,frame:n,prettyPrint:a,skipContext:w}={}){super({objectMode:!0,read:()=>{}}),this.compact=m,this.context=L,this.encoding=i,this.flatten=t,this.frame=n,this.prettyPrint=a,this.skipContext=w,g&&(this.context["@base"]=g.value||g.toString()),r.on("prefix",(N,j)=>{this.context[N]||(this.context[N]=j.value)}),this.handleData(r)}async handleData(r){try{const g=(await bn(r)).map(ie.toJsonldQuad),m=await ue.fromRDF(g),L=await this.transform(m,this.options);this.push(L),this.push(null)}catch(g){this.emit("error",g)}}async transform(r){return this.compact&&(r=await ue.compact(r,this.context)),this.flatten&&(r=await ue.flatten(r,this.context)),this.frame&&(r=await ue.frame(r,this.context)),this.skipContext&&r["@context"]&&delete r["@context"],this.encoding==="string"?this.prettyPrint?JSON.stringify(r,null,2):JSON.stringify(r):r}static toJsonldQuad(r){return{subject:ie.toJsonldTerm(r.subject),predicate:ie.toJsonldTerm(r.predicate),object:ie.toJsonldTerm(r.object),graph:ie.toJsonldTerm(r.graph)}}static toJsonldTerm(r){return r.termType==="BlankNode"?{termType:"BlankNode",value:`_:${r.value}`}:r}}class Tn extends Qt{constructor(r){super(ie,r)}}export{Tn as default};
